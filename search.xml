<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>显著图</title>
      <link href="/posts/4a9e635/"/>
      <url>/posts/4a9e635/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>显著图(Saliency map)是一种突出人们眼睛首先关注的区域的图像。显著图的目标是反映像素对人类视觉系统的重要程度。</p><p>显著性是图像的突出部分，我们的大脑会特别关注这个部分。例如，大家有没有曾经在看广告的时候被一些特别的内容吸引，为此我们还特意停下来多看了一会儿？这就是广告的显著性，即使让我们可以一眼看到广告，也会被他吸引。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0f517f311d0e5653ad5465967e7c7390.jpeg#pic_center" alt="人首先看房子和灯塔，所以在显著图上它们应该突出显示"></p><h1 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h1><p>输入：原始图像</p><p>输出：一张<strong>灰度热力图</strong></p><ul><li><p><strong>亮色区域</strong>：显著性高，通常对应目标或关键区域</p></li><li><p><strong>暗色区域</strong>：显著性低，通常为背景或冗余信息</p></li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>显著图的目标并不是进行精确分割，而是衡量“哪里更值得关注”。</p><p>显著性往往来源于：</p><ul><li>与周围区域的对比差异</li><li>结构或纹理突变</li><li>语义层面的目标信息</li></ul><p>显著图常作为：</p><ul><li><strong>前处理手段</strong>（减少背景干扰）</li><li><strong>可解释性工具</strong>（模型关注区域可视化）</li><li><strong>辅助特征</strong>（提升检测或分类性能）</li></ul><h1 id="传统显著图（底层特征）"><a href="#传统显著图（底层特征）" class="headerlink" title="传统显著图（底层特征）"></a>传统显著图（底层特征）</h1><p>该类方法仅依赖图像本身，不涉及学习过程，主要利用人眼对以下特征的敏感性：</p><ul><li>亮度（Intensity）</li><li>颜色（Color）</li><li>方向和边缘（Orientation）</li></ul><p>其核心思想是：</p><blockquote><p><strong>与周围区域差异越大的位置越显著。</strong></p></blockquote><p>典型方法包括：</p><ul><li>Itti-Koch 显著性模型</li><li>Spectral Residual（SR）</li><li>Frequency-Tuned（FT）</li></ul><p>📌 优点：</p><ul><li>计算简单、速度快</li><li>无需训练数据</li></ul><p>📌 局限：</p><ul><li>无法理解高层语义</li><li>易被噪声或复杂背景干扰</li></ul><h1 id="基于深度学习的显著图（高层语义）"><a href="#基于深度学习的显著图（高层语义）" class="headerlink" title="基于深度学习的显著图（高层语义）"></a>基于深度学习的显著图（高层语义）</h1><p>这类方法通常基于 CNN 或 Transformer，通过大量数据学习：</p><ul><li>什么是“目标”</li><li>什么区域与任务最相关</li></ul><p>常见方向包括：</p><ul><li>显著目标检测（Salient Object Detection）</li><li>基于 U-Net / FCN 的显著性预测</li><li>Transformer 显著性建模</li></ul><p>📌 优点：</p><ul><li>能识别语义目标（人、车辆、病灶等）</li><li>显著性结果更稳定、更准确</li></ul><p>📌 局限：</p><ul><li>依赖标注数据</li><li>训练成本较高</li></ul><hr><blockquote><p><a href="https://arxiv.org/pdf/1312.6034">Deep Inside Convolutional Networks: Visualising Image Classification Models and Saliency Maps</a></p><p><a href="https://zhuanlan.zhihu.com/p/644181243">显著图: Saliency Map</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度图</title>
      <link href="/posts/90af7429/"/>
      <url>/posts/90af7429/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>深度图（depth map）是一种灰度图像，其中每个像素点距离相机的距离信息。它是计算机视觉中常用的一种图像表示方式，用于描述场景的三维结构。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/033393fe6c9f2139b8176c97e2a7a084.png" alt=""></p><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><ol><li>通过激光雷达或结构光等传感器获取深度信息，再将其转换为深度图像。</li><li>利用双目或多目相机的视差信息计算深度，再将其转换为深度图像。</li><li>利用先验知识或模型对图像进行分析，推测出每个像素点的深度信息。</li></ol><h2 id="激光雷达-结构光"><a href="#激光雷达-结构光" class="headerlink" title="激光雷达/结构光"></a>激光雷达/结构光</h2><p>激光雷达或结构光等传感器获得的深度，可以得到绝对深度，因为他们的数据是测出来的，根据TOF计算得到的真实距离。所以在连续的图片序列中，由于深度是绝对的，他们具有一样的参考价值。</p><blockquote><p>TOF(time of fight):</p><p>过激光/雷达波发出和收到的时间差，结合光速，计算信号在这段时间所走过的路程</p></blockquote><h2 id="RGB-D相机"><a href="#RGB-D相机" class="headerlink" title="RGB-D相机"></a>RGB-D相机</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9eadcfcffc0bfe505fd62345849c3727.png" alt=""></p><h2 id="双目相机"><a href="#双目相机" class="headerlink" title="双目相机"></a>双目相机</h2><p>视察信息计算深度</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/62ad3fa4d46fa03419d41aa1efe03379.png" alt=""></p><h2 id="深度学习模型"><a href="#深度学习模型" class="headerlink" title="深度学习模型"></a>深度学习模型</h2><ol><li>从RGBD相机的输出结果中，获取深度分量，得到真实的深度图。</li><li>仅输入RGB图，让模型生成对应的深度估计图</li><li>对模型的深度估计图和实际的深度图求差，获取估计的误差</li><li>深度学习网络的优化目标即为减小估计深度与实际深度的误差</li><li>在经过大量的训练之后，就能获得一个可以根据RGB图估计深度图的网络了</li></ol><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5989bd0333149d7f1877dbddaeca9bcb.png" alt=""></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li><p>三维重建：深度图可用于创建三维模型，例如建筑物、雕塑、人体等。</p></li><li><p>虚拟现实：深度图可用于创建虚拟现实环境，例如游戏、培训模拟器等。</p></li><li><p>自动驾驶：深度图可用于帮助自动驾驶汽车识别道路、障碍物和其他车辆。</p></li><li><p>医学成像：深度图可用于医学成像，例如X射线、CT扫描和MRI。</p></li><li><p>图层分隔：判断图片素材中物体的远近关系，实现图层前后信息的获取。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>皮亚诺公理体系</title>
      <link href="/posts/7c0b9456/"/>
      <url>/posts/7c0b9456/</url>
      
        <content type="html"><![CDATA[<p>皮亚诺公理体系是意大利数学家朱塞佩・皮亚诺于 1889 年提出的关于自然数的公理系统，旨在为算术提供严格基础，核心是 5 条公理，可完整定义自然数集并支撑数学归纳法与算术运算。</p><h1 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h1><ol><li><strong>存在初始元</strong>：0 是自然数</li><li><strong>后继封闭性</strong>：每个自然数 a 都有唯一确定的后继数 a’（或记为 S (a)），且 a’ 也是自然数。直观上 a’ = a + 1。</li><li><strong>无前驱性</strong>：0 不是任何自然数的后继数，排除循环或回溯结构。</li><li><strong>后继单射性</strong>：若 b’ = c’，则 b = c，保证每个数的后继唯一，无分支或重复。</li><li><strong>归纳公理（数学归纳法原理）</strong>：设 P (n) 是关于自然数 n 的命题，若 P (0) 为真，且当 P (k) 为真时可推出 P (k’) 也为真，则 P (n) 对所有自然数 n 为真。此公理确保自然数集是 “最小归纳集”，排除额外孤立元素。</li></ol><h1 id="核心作用与意义"><a href="#核心作用与意义" class="headerlink" title="核心作用与意义"></a>核心作用与意义</h1><ol><li><strong>定义自然数</strong>：通过初始元、后继与归纳公理，唯一刻画自然数集的结构，避免非标准模型（如循环、分支或额外元素）。</li><li><strong>推导算术运算</strong>：基于公理可定义加法（a+0=a，a+S (b)=S (a+b)）、乘法（a×0=0，a×S (b)=a×b+a），并证明交换律、结合律、分配律等性质。</li><li><strong>数学归纳法基础</strong>：归纳公理是数学归纳法的逻辑根源，用于证明自然数的普遍性质（如求和公式、整除性等）。</li><li><strong>数理逻辑起点</strong>：皮亚诺算术（PA）是一阶逻辑中对该公理体系的形式化，是元数学研究（如哥德尔不完备性定理）的核心对象。</li></ol><hr><blockquote><p>4.30 F@h.OK 05/19 nQx:/ 皮亚诺公理体系，1+1=2，以及罗素的遗憾 如何从1+1=2开始重新构建数学？这关系到数学大厦的地基。罗素用三卷《数学原理》开始了他的尝试。# 微积分 # 高等数学 # 抖音精选  <a href="https://v.douyin.com/uh8pEATVLk0/">https://v.douyin.com/uh8pEATVLk0/</a> 复制此链接，打开Dou音搜索，直接观看视频！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最优化基础——基本概念</title>
      <link href="/posts/6356d855/"/>
      <url>/posts/6356d855/</url>
      
        <content type="html"><![CDATA[<h1 id="凸集、凸函数"><a href="#凸集、凸函数" class="headerlink" title="凸集、凸函数"></a>凸集、凸函数</h1><ul><li><p>凸集：假设集合 $X \subseteq \mathbb{R}^n$，如果对于任意两点 $ \mathbf{x}_1, \mathbf{x}_2 \in X$ 和 $\alpha \in (0, 1)$，总有 $\alpha \cdot \mathbf{x}_1 + (1 - \alpha) \cdot \mathbf{x}_2 \in X$ （点$\mathbf{x}_1$和点$\mathbf{x}_2$连线任意一点），则 $X$ 是凸集合。</p></li><li><p>非凸集合</p></li></ul><p><img src="data:image/png;base64,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" alt=""></p><ul><li>凸函数：假设集合 $X \subseteq \mathbb{R}$，并且 $f : \mathbb{X} \rightarrow \mathbf{R}$，如果对于任意两个点 $\mathbf{x}_1, \mathbf{x}_2 \in \mathbb{X}$ 和 $\alpha \in (0, 1)$，总有 $f[\alpha \cdot \mathbf{x}_1 + (1 - \alpha) \cdot \mathbf{x}_2] \le \alpha \cdot f(\mathbf{x}_1) + (1 - \alpha) \cdot f(\mathbf{x}_2) $，则称 $f$ 是在 $X$ 的凸函数，上述取 $&lt;$ 时则称 $f$ 是 $\mathbb{X}$上的严格凸函数。</li></ul><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUREhIVFhIWGRgVFxcYFhcYFRYYFhUYGBcXFRcYHSggGBolHRUXITEhJSkrLi4vGB8zODMsNygtLi0BCgoKDg0OGhAQGi0lHyUrLS0rMC0tLS0rLysrLS0tLS8tKy0tLSstLS0tLSsvLi8tLS0tLS0vLS0tNS0tLS0tLf/AABEIAKgBLAMBIgACEQEDEQH/xAAcAAEAAQUBAQAAAAAAAAAAAAAAAgEDBAUGBwj/xAA+EAABAgMEBwYDBwQCAwEAAAABAAIDESEEEjFBBQZRYXGBkRMiobHB8Acy0RQjM0JS4fFicoKyksJDg6I0/8QAGgEBAAMBAQEAAAAAAAAAAAAAAAMEBQIBBv/EAC4RAAICAQMDAgQFBQAAAAAAAAABAgMRBBIxEyFBBaEiUWHhMkJxsfAjgcHR8f/aAAwDAQACEQMRAD8A9xREQBERAEREARa77bEm2bKXnBxk4ANEQtaa7Wi9/IWe14OBQEkREAREQBERAEREAREQBERAEREAREQBEWM60ERbku7dvEydQzkO98u2mKAyUVsRdxkpCINqAkiIgCIiAIiIAiIgCIiAIiIAhUXvABJMgKk7AFjxIrIgMO987XYA4VaayoccdiAWNhDTN03OLnYzkC4kAbgCAsWzQYzbgc68Wzn3nVmMxITrt3qUHR4Dw8OJIEspVvGn/N27DYtgxgH1zXoMPScXs4MWKT8rHO3CTSaLD1U0h9ossOI+rwLr6fnbQnnjzVvXWIRZIjRi+6zq6Z8AVzmoNs7OK6CT3Ysi3c9on4t/1CqzvUblB+UXIUKWnlZ5T9vJ33Z7CR73pJ20FTRWSmQvnMHzVREG1SVCEBVFDsxlTgl07ev7ICaKF47OhQRBw4oCaIiAIiIAiIgIvNDQncMfFY9jfdDYb33ot2Zwmd8hz6LKWK6C0xL4HelKeQAnlt7zupQGQ58uOxRDJ1PTJSa2SkgIMxPH0CkRPFRbieXqpoCHZjKnD6JdO3qPopogIXjmOidoOHGimiApNVUOzGyXCnkl07eqAmihM7J807QZ0QE0VA4HBVQBW3xmiUziQ3mcFcViLDaaXZmYOyowmQgLZdCiBwIDpTYZitaEDxwUYVhbMOkaTkLxOM5k1zmeqvWaytZgKmvuavoAiIgOW11dPs2ZAl55C6P9ndFyrGFpBaZOvX2nZWc+suq6HWCLejPM6NAhjpPzdJaeI2VP0Dw/gL5rWWuWok14/wAfc06bVCpR/nc9A0bbBFhtiNwcKjYRRw5EELKXG6qaRuROxJ7j6jYH4f8A0B1A2rslvae5W1qRnTWHgIiKc5CIiAoSuc1d039six3s/wDzwoggQz+tzBeiRBum5oG5s81z3xU1t7KGbJBd97EHfIxYx3/Z2WwV2LdfDXR/Y6Pszc3gxj/7Deb0a5o5LhTzLCO9uIZZ1aIi7OAiIgKErFZaj2haRIBs6gznPDYeR/bJc/IY+8VRrMzU+XBAUkTjQbM+amAqogCLFtWkIcMyca7AC48wBRXoEZr2hzSC01BGC5Uot4T7jBUfMeA9VNQHzHgPMqa6AREQBEXH6768Q7EOzYBEtDhMNn3WD9USVeAxO5eSkorLOoQlN7YnYIvBWa8aQe++60uEzOQa0MA2Bt2RHGa9J1N1v+0fdRgBF/K4Ua+W7J3moY6mEpbS/b6ZdXV1E015xyjsVRxkk1ECdcsvqpzOIw294nOQ9VdUGYnj6BTQBa63xez+8nJjXfebmkAX/wDEyJ3TWxVmJDDrzSAWkSIOBBmCDyQEwDtnx+oS/tBHj5LSav2ose+wxCS+DLsycYkE/I4k4uA7pOZE1vl4nk9awUa4HBRjxQ1pccGgk8AJlVcwFabWSPdYIYNYhrnJranqZDmubJ7IuRy3hZObiuJILsXkl250y4+PosaK7E77p5U859VcivqSdmWThU+nRYxeKeI35+q+fjQ5PLIpakx4xqRPEiRzEq0ORFV3WrWmhHZdcfvmfMP1DC+Nxz2HkvP3nAbJu64eax4dtfDeIkNxa9lRxOR2gywV/TKVT+hyr88nsaLltC66wIgDYxEKJgZ/huO1rjhwPit7E0rAa28Y8IN2l7ZdZrTUk+CdST4MxcxrrrWyxwyAQ6O4G4z/ALP2NB64bZabWX4lQmBzLIO0iVF8j7pu8ZvPhvXldttb4r3RIry95+ZxxMvcpDBQW3bViPJ6sZI3IlqtADnF0SNEDS44lz3Bs+An4L6PgQQ26xtGtaGgbAKDyXivww0d2tvY4juwmmIdgIF1vi+fJe3NxPIe+q80y+FskslnCJoiKyRhW4rjMAZ+n8q4sSE59914G7OTZgbDMgg4YY+tAL7HAUw4+6q4hCh2Yypw+iAmtZbtIyJZD+YULj8rScAdprhwnvyLdaHQ2OdQywyqaNHUhc2I0myzdR083HEz24rM9R1cqYqNfL9kSVxT7ssWiO4T71ScXd69vLhUDlSQkr2hdJ9k43vw3Gt3vAO/UJZSFaZBaTSdouncBIbp5eAWniW8gzzAx4/wsnTuyuW9c/uTzcJrB6nB0rBfEuMeHEjKomKyJ2yrLctgvI4GmS0gzE21E8ZjAzC6Gw62vFCQQNonMy2iR81rw9Rj+eLXuQ9F+Hk7tFoIGs7Di00FZEeRkVqNb9f2WVl2GwujuE2h1GtH6nSMyN2asx1dMuJBUzbxgzdedaxY4d1knWh4NxuTR+t27YM+q8Tiw3Pc57yXPdVziZkuNSSVZtdtix4ro0ZxfEcZknyAyAFAFsLG2YAKqX2uTz4N3SaBbO0viLcGDI8B78lvNFAtLSCRIzpiJZjnJYzLNszK22j2SO/3h1VCyfYsV2uLcZHqWhLf28IOOI7rx/UPQ481tFw2g9Iw7K5jYsQMZEIhiZxefllvnMc13BK2tJf1qlLzwfOamtV2NLgjCw5nzU1GHgOCkrJAFA/MOB9FNYkGC5pJJBm4kY0BG/ggNPrfY3BrbXCpFgTJliYZ+ae2WMuIzWfoXTLI7dkSUy3d+pu1p/lbNzZiRwXnNvsn2WOYX/j+eGf6CcAdrTQ7rpzVW6UqnvXdef8AZ65fD3PQrTaGsaXvMmjE+8TuXFaRtpiPdENAaAfpbiznOZ4ncsV0culee50sC5xdLfU0yPVWnvvcPfk5e97+yXYzdRqM9kIjqAZmp/uFTyWLaHCux1OBw98FJ8SpPL/IY9fRYkZ9ZZGp3H35K7XoSl1GWrRnLESHvqsCO+dc5y6ZdVefFpvqTzWBFiZ5y8SpXo8HcZssR422mJ64VWtjvG7+FkWu0AAk7h0y6rUw4pIdPGf+3sqrOpRlt8l2uEnB2eF2Lk+XuZSdPfFWyffGirUmQqTQAZk5BVbK8E0JHrXwb0cWwYtoI/EcGN/tZOZ/5OI/xXoUPPj6SWv1a0Z9mssGBmxgDt7z3nnm4krYQsOp6kqzCO2KRYJoiLoBQi4dD4qai8TBCAkiiwzAKkgNHrJF/DhjEkv/AONAOrvBaR75meWH+WfhRX9L2u/aXAH8OTBvOJHUy5blYtDZCX6qbw73XksXVVu25v8AsVrL9rwaDSWe0nww9FzdpcQTXMCXviuk0o3AZifhTxmFy9qd5n1U0NM0jiF+S3EtG2Yr7wVYdulWuKw40Wo5rFc+nvNeSoLMLTdO089gpjiAa1ynwWitcZ8R5e8zcTU8NmxVAJM/fvBSY3DmffVRKEYvsX6rPmQhwVtbC2teqxYLcFsLKyh309FxOXY0qb9rN3ZYM2g5nzPuS2ljsOG8zPI/WQWNolkyAdn7D1XWaI0U+IC+/caDd+UOLpYuFe7s4gqlGuy6eyHJ1q7orE2eTa/aVLrU2GDNtnlzfMOceIk0civZNWdIF0PsnTJDZtP9JkJHeCQOEthXN6a+Edlilz4MaLCeSSZkRGkkzJIdJ2P9S6vV/RDrPDDYjg55uNJGEmDKdamZ5yyX0NFHSSS8I+esnOdm79TdoiKyehQi4cx5qahFwPBATWn1o0T9og938VnehnCsqtJ2OFOhyW3CqvGk1hg8os9pa4TIrUGYkZgkFrthBmCDgZqcSNsmd/KvMjxCzPiBo51lifboYnAiEC0NH5HGgjAbDQO4A7VpTaZihoagzmDnMSx29Vd9PpTeDF1VbjIvRoowypX/AFKwI0eYM86e/PorMe0ZbfLNYEW0V4U4r6OvTIjhU2X7RH64cQsKLHnM+6KxHtG/DA7ysQvvf2ihO3cPVV9c69NW5z/6y3XpnJ4KRXX5HIYbzmVbtEKQvDbI8xT3vWYwV8lcbDBaWnDD9+S+HeplK7qP5+xttQVPSXBqA734Lqvhnof7TbWEicOD967ZMfht6yPIrlTZ3hwZdcXkhrQBMuJwujfPBe+fD7Vn7FZg14HbxO/FIrIyowHMNFOMzmtKajJpozqovPc6clUhYDgqRcCprwshERAFjW+1dm29dLqylyJ9JcSFkogIQcOEx0Ks6QtQhQ3RDkKDacgOJoke0thhznmQB6zAkBtJK5HSeljF7zhdYJ3Wz+U7XSoXeVRXE9KLfBXvvjVH6mhbbC15c/5plxO1zjMmeWPitg+3TbeEnGVTgZbv2XPaQjSNeM/r4LXttpBEjnPp7Chlp2nkzk93J0trcHtL8wKjOWMyMjuXI6RbI8lt7PpifzAGeeB6jl0UI9ngxsHlhdPEAgDIDrtViM4YxJYPIxcWcjHcfDzVoVMuq6SLqsSZ9qCDsFZcyoHRLYYk0HZMymdpVW+UPyluuaNOGnhIeavNhy6LJfBx4+Styx4rPlEuxtKw4dRuWdZBgOaxWZ+/eKzIAry8z+ygnHsWY3HQ6OMpuzHjIYeJXqGj7PchsZmAJ8cz1mvM9VoZfFhsxm4OO8N758pc16j2gzpxVr06rapT+fYXW78ImoOxHM++qmCofm4Dz/haZATREQBWbQXTZLAuk7+26fWSvIgIQT3RwU1CFhzPmpoC1aYDYjHQ3tDmOBa5pqCCJEFeB6z6PjaKtBhd59jeSYLjWQxLLx/O3ZmK5le/EzoOawNPaEg2uA6zxmzY7Da0jBzTk4LuuyVct0XhkdlamsM8EOlYbh3XSJ20I+vJY8a1N/UKc68lj626sx9HRuzigmGT91FA7kQf9XDNvpVauFH3ha8fWbox/As/P7fchiow8GzvTxoMZZ/sFeaRhlsWBDi85K82JvqOiw9VO7VT3WPP7L9Dvq4M0P6+Sm2JmsEx5V6/Xiu++HepLo5barSwiAO9DYcYpnRzh+jj83DGGOkx3Z51JTeEbn4b6suErbHZj+C04gH/AMjgduW6uYXoweFUBC0HFTpJLCJ0sIjFw5jzU1auVpgFdXp6EREARFGI4gTAJ3CU/EgIDGt1lERrmOwcOYINCN4MjyXnVvvMe6G8SIMnccpbiJHovRLPFcXG8JScWjuubTHPHDEUK53XzRhLPtDBVolEAxLMncWnwO5W9JKKsSlwynrKOpHK5R51pKNUzy8fdFoo0WWGQ9+SztIxZiuPv0Wijx6np76rVv0mCnXB4M37VLosuBbK47AtCYyk2OPFZtlBLtOxstt2GWQ/jn4KxpnTTYfcb3nAY5Nn5mUla1K0JEt0bs292GzvRYkvlBwDf6zWWzHKR9r0Vq/ZrOwMhQWNGZkC529zjUlZ9tSzgmppbe5ngVl1niw3TaIZ3Ees8V1+jHWXSTZQ2iDami8WnB3T5hvxGYqvULdoGyxhKLZ4T+MNpPIymFy9s+GVlERseyPiWaM0hzS034dMQWOM5HMAhUbdCn8UHiX85Lyk8YfdHnlosT4bixwIcDIg7j+yrCoTyHh+67/WLRDXC84fesADro+eYxAzz8di5Q6PIpz8vUhQ1/1I91hrlFSyXTlg6n4eQJxXvyYwDm8/Rh6rvlzmoli7OzXpSMRxfyHdbyk2fNdGtGmGyCRYjwQLBw4KkIYnbhwVX1p14KalOgiIgCIoxQSCAZGRkdhlQoCjMTx9AjjkOe5Ytla9gDXmbjOs5iV4kCZxIBA5LMaJIA0SVURAYeltFwbTCdBjw2vhuxBHQjYRtC8Y1p+ENpgkxLC/t4ePZPIbGbua4ya8cZHivc0XUZOJ44p8nypH0XbITrsSyWhrhkYMTzDZHkVsdEasaQtBuwrJGp+aI0wmt/yiSnymV9NIpet9CPpRPNtT/hbDglsa2ubGiiohifYtO+dYh4yG5ejQRQKahCwHAKKUnLkkUUuCai90uOSkoME69FyelWNkpIiAIiIAiIgIRcjvH09VSIL02ymDQ7JHJSe2YkoiYymN30QHiGvmg3WSMWgfcvm6Ed2bDvbPmJb1wtpf5r6Y1g0PCtkF0CJnUH8zHDBw3+dQvAdaNW41liGHFbLG68fJEGRYdu1uI8V9Bptarqtk/wAS9zqqiM+y5ObdGKzNDWKLaYzIEFt6I8yAyE8XOOTQJklYUCwxYsRsGCx0SK6jWNE3H6DfgF9AfDTUUWCH2kWTrXEHfIqIbcezYfM5ncAquptjFfUhnRh4Oh1X0DDsVnbAhjCr3Sq95+Zx9BkABktuiLJJF2CIiA1mmrNNvaATLAZ72H5uJGPUZrmrFoZ8VzroHZkyLjhTG4PzHoJz5dwrVmhhrZNAAEwAMBVQ9GO/eRzqU33K2eCGNaxok1oDQNgAkFNzpKqtip3DzUxISY3bjmpIiAIiIAqEqqIDBtFpeJyYflJAlPvTkAS2YV6zAloMrriJkZT4HBZChEYTg4jhL1QFL5GI6fRSa4HArX2TRz23JvvXJ5GZvYipO7osq1RWNkXGUzIGs58kBkIsaBHDp3Teukg5GY81eEQcDvQE0REBQqkLAcAkTA8ChMggKPrTqpqLGy4qSAIiIAiIgCIiAIiIDDtMeTmi7i67WlMyCFO02Nr23HtbEYcWvAcPFZKIDBsNggQZ9lBhwp1N1jWz4kCqzkIViO9rBMuujDaOnJAX0Vu+RiOY+mKm1wOCAqiIgChCw6+ZU1CH8o4IA85DEqTRJRYM/clNAEREAREQBERAEREAWHbBecxhh3hMkurJpAp1qFmIgLUCztZO6JTqd55rFtdsLXllybbt6dZTrIUG4dVnogMezzLQ4UJE5HIq52ksRzFQri19ogxjeDXATdMGZoLgEpS/VM/ygMx7ptPBG1M8hh9UdCB57KKYCAqiIgCIiAIiIAiIgCIiAIiICxaC+bLkpT789kst85eKlHgNeJOExj6epV1EAUHQwVNEBb7w3+aqIgwz3qaxrGx10iJjM4kGmVZIDJJVllZDIAT+ikWHI9aqUNshJASREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREAREQH/9k=" alt=""></p><ul><li>凹函数：假设集合 $X \subseteq \mathbb{R}$，并且 $f : \mathbb{X} \rightarrow \mathbf{R}$，如果对于任意两个点 $\mathbf{x}_1, \mathbf{x}_2 \in \mathbb{X}$ 和 $\alpha \in (0, 1)$，总有 $f[\alpha \cdot \mathbf{x}_1 + (1 - \alpha) \cdot \mathbf{x}_2] \geq \alpha \cdot f(\mathbf{x}_1) + (1 - \alpha) \cdot f(\mathbf{x}_2) $，则称 $f$ 是在 $X$ 的凹函数，上述取 $&gt;$ 时则称 $f$ 是 $\mathbb{X}$上的严格凸函数。</li><li>非凸非凹函数</li></ul><h1 id="凸优化、非凸优化"><a href="#凸优化、非凸优化" class="headerlink" title="凸优化、非凸优化"></a>凸优化、非凸优化</h1><p>优化问题：</p><script type="math/tex; mode=display">\begin{aligned}\min &\ f(\mathbf{x}) \\\text{s.t.} &\ \mathbf{x} \in \mathbf{C}\end{aligned}</script><p>如果 $\mathbf{C}$ 是凸集，且目标函数 $f(\mathbf{x})$ 是 $\mathbf{C}$ 上的凸函数，则称这样的优化问题是<strong>凸优化问题</strong>。</p><p>凸优化问题性质：</p><ol><li>凸优化的局部极小点就是全局极小点；</li><li>如果目标函数是严格凸函数，则凸优化问题具有唯一的全局极小点；</li><li>凸优化的全局极大点必定能在可行域的边界上达到。</li></ol><h1 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h1><p>梯度是多输入单输出函数的广义导数。</p><p>设函数 $f : \mathbb{R}^n \rightarrow \mathbb{R}, \mathbf{x} \in \mathbb{R}^n$。如果 $f$ 关于点 $\mathbf{x} = (x_1, x_2, \dots, x_n )$ 各分量的一阶导数 $\frac{ \partial f(\mathbf{x}) }{\partial x_i}(i = 1, 2, \dots, n)$ 都存在，则称函数 $f$ 在点 $\mathbf{x}$ 处一阶可导，并称向量</p><script type="math/tex; mode=display">\nabla f(\mathbf{x}) = \left[ \frac{\partial f(\mathbf{x})}{\partial x_1} \quad \frac{\partial f(\mathbf{x})}{\partial x_2} \quad \dots \frac{\partial f(\mathbf{x})}{\partial x_n} \right]</script><p>为 $f$ 在 $\mathbf{x}$ 处的梯度向量。</p><ol><li><strong>方向</strong>：梯度方向是函数在该点<strong>上升最快</strong>的方向</li><li><strong>大小</strong>：梯度的模长是该点的<strong>最大变化率</strong></li><li><strong>垂直性</strong>：梯度方向与<strong>等值面 / 等高线</strong>垂直</li></ol><h1 id="Jacobi矩阵、Hessian矩阵"><a href="#Jacobi矩阵、Hessian矩阵" class="headerlink" title="Jacobi矩阵、Hessian矩阵"></a>Jacobi矩阵、Hessian矩阵</h1><h2 id="Jacobi矩阵"><a href="#Jacobi矩阵" class="headerlink" title="Jacobi矩阵"></a>Jacobi矩阵</h2><p>雅可比矩阵（Jacobian Matrix）本质上是<strong>多元向量值函数的 “导数”</strong>，它把函数在某点的<strong>局部线性近似</strong>用矩阵形式表示出来，是连接<strong>非线性</strong>与<strong>线性</strong>的桥梁。</p><p>设函数 $ f : \mathbb{R}^n \rightarrow \mathbb{R}^m $。如果函数 $ f = (f_1, f_2, \dots, f_m) $ 的各个分量关于点 $\mathbf{x} = (x_1, x_2, \dots, x_n)$ 各个分量的一阶导数 $\frac{\partial f_j(\mathbf{x})}{\partial x_i}(i = 1, 2, \dots n; \quad j = 1, 2, \dots, m)$ 都存在，则称矩阵</p><script type="math/tex; mode=display">Df(\mathbf{x}) = \begin{bmatrix}\frac{\partial f_1(\mathbf{x})}{\partial x_1} & \frac{\partial f_1(\mathbf{x})}{\partial x_2} & \dots & \frac{\partial f_1(\mathbf{x})}{\partial x_n} \\\frac{\partial f_2(\mathbf{x})}{\partial x_1} & \frac{\partial f_2(\mathbf{x})}{\partial x_2} & \dots & \frac{\partial f_2(\mathbf{x})}{\partial x_n} \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial f_m(\mathbf{x})}{\partial x_1} & \frac{\partial f_m(\mathbf{x})}{\partial x_2} & \dots & \frac{\partial f_m(\mathbf{x})}{\partial x_n}\end{bmatrix}_{m \times n}</script><p>为 $ f $ 在点 $\mathbf{x}$ 处的 Jacobi矩阵。</p><h3 id="局部线性优化"><a href="#局部线性优化" class="headerlink" title="局部线性优化"></a>局部线性优化</h3><p>一阶近似：</p><script type="math/tex; mode=display">f(\mathbf{x}) \approx f(\mathbf{x}_0) + Df(\mathbf{x}_0) \cdot (\mathbf{x} - \mathbf{x}_0)</script><p>雅可比矩阵描述了函数在该点<strong>变化最快的方向</strong>和<strong>变化率</strong></p><h2 id="Hessian矩阵"><a href="#Hessian矩阵" class="headerlink" title="Hessian矩阵"></a>Hessian矩阵</h2><p>Hessian矩阵用于描述函数在某点的<strong>局部曲率</strong>，是判断多元函数极值的核心工具。</p><p>设函数$f: \mathbb{R}^n \rightarrow \mathbb{R}$，$\mathbf{x} \in \mathbb{R}^n$。如果函数$f$ 关于点$\mathbf{x} = (x_1, x_2, \dots, x_n)$ 各分量的二阶导数 $\frac{\partial ^ 2 f(\mathbf{x})}{\partial x_j \partial x_i}(i, j = 1, 2, \dots, n)$都存在，则称函数 $f$ 在点$\mathbf{x}$ 处二阶可导，并称矩阵</p><script type="math/tex; mode=display">\nabla^2 f(\mathbf{x}) = \begin{bmatrix}\frac{\partial^2 f(\mathbf{x})}{\partial x_1^2} & \frac{\partial^2 f(\mathbf{x})}{\partial x_2 \partial x_1} & \dots & \frac{\partial^2 f(\mathbf{x})}{\partial x_n \partial x_1} \\\frac{\partial^2 f(\mathbf{x})}{\partial x_1 \partial x_2} & \frac{\partial^2 f(\mathbf{x})}{\partial x_2^2} & \dots & \frac{\partial^2 f(\mathbf{x})}{\partial x_n \partial x_2} \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2 f(\mathbf{x})}{\partial x_1 \partial x_n} & \frac{\partial^2 f(\mathbf{x})}{\partial x_2 \partial x_n} & \dots & \frac{\partial^2 f(\mathbf{x})}{\partial x_n^2}\end{bmatrix}_{n \times n}</script><p>为 $f$ 在点$\mathbf{x}$ 处的Hessian矩阵。</p><p>当 $f$ 在点 $\mathbf{x}$ 处各项二阶偏导数均连续时，则  $\frac{\partial^2 f(\mathbf{x})}{\partial{x_j} \partial{x_i}} = \frac{\partial^2 f(\mathbf{x})}{\partial{x_i} \partial{x_j}}$。</p><blockquote><p>二阶偏导数连续：</p><p>函数 $f(\mathbf{x})$ 的所有二阶偏导数都存在，且在定义域内处处连续。</p></blockquote><ul><li>Hessian 是梯度的雅可比矩阵。</li></ul><h3 id="局部线性优化-1"><a href="#局部线性优化-1" class="headerlink" title="局部线性优化"></a>局部线性优化</h3><p>二阶近似：</p><script type="math/tex; mode=display">f(\mathbf{x}) \approx f(\mathbf{x}_0) + \nabla f(\mathbf{x}_0)^\top (\mathbf{x} - \mathbf{x}_0) + \frac{1}{2}(\mathbf{x} - \mathbf{x}_0)^\top \nabla^2 f(\mathbf{x}_0) (\mathbf{x} - \mathbf{x}_0)</script><p>Hessian 决定了函数在该点$\mathbf{x_0}$的<strong>弯曲程度</strong>。</p><h3 id="极值判定"><a href="#极值判定" class="headerlink" title="极值判定"></a>极值判定</h3><p>设 $\nabla f(\mathbf{x}_0) = \mathbf{0}$（临界点），则：</p><ul><li>$\nabla^2 f(\mathbf{x}_0)$ <strong>正定</strong> $\implies \mathbf{x}_0$ 是<strong>严格极小值点</strong> </li><li>$\nabla^2 f(\mathbf{x}_0)$ <strong>负定</strong> $\implies \mathbf{x}_0$ 是<strong>严格极大值点</strong> </li><li>$\nabla^2 f(\mathbf{x}_0)$ <strong>不定</strong> $\implies \mathbf{x}_0$ 是<strong>鞍点</strong> </li><li>$\nabla^2 f(\mathbf{x}_0)$ <strong>半正定 / 半负定</strong> $\implies$ 需<strong>进一步判断</strong></li></ul><blockquote><p>正定：</p><p>对 n 阶对称矩阵 A，若对<strong>任意非零向量</strong> $\mathbf{x} \in \mathbb{R} ^n$，都有：$\mathbf{x} ^T A \mathbf{x} &gt; 0$，则称 A 为<strong>正定矩阵</strong>。</p><p>等价：</p><ul><li><p><strong>特征值</strong>：A 的<strong>所有特征值都大于 0</strong></p></li><li><p><strong>顺序主子式</strong>：A 的<strong>所有顺序主子式都大于 0</strong></p></li><li><p><strong>合同</strong>：A 合同于单位矩阵 I</p></li></ul></blockquote><hr><blockquote><p><a href="https://www.bilibili.com/video/BV19M4y1n7M3?vd_source=59c9078be8272e804fcbbcf1da9a9f94">最优化基础—-基本概念：凸优化、梯度、Jacobi矩阵、Hessian矩阵</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘布局</title>
      <link href="/posts/a6b1e5df/"/>
      <url>/posts/a6b1e5df/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1f8zNByE8e?vd_source=59c9078be8272e804fcbbcf1da9a9f94">Ctrl、Alt、F4…每个按键都是怎么来的？｜技术｜播客｜原来是这样</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中的编程概念</title>
      <link href="/posts/c8e7894a/"/>
      <url>/posts/c8e7894a/</url>
      
        <content type="html"><![CDATA[<h1 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h1><p>前向声明（Forward Declaration）在使用某个类/函数/枚举之前，告诉编译器某个类型存在，但不提供完整定义。编译器只需要知道 “有这个标识符” 就能进行语法检查，而不需要知道它的具体实现细节。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向声明告诉编译器某个类型存在，但不提供完整定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>;     <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span>;   <span class="comment">// 前向声明</span></span><br></pre></td></tr></table></figure><h2 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h2><ol><li><p>解决循环依赖</p><p> <code>A.h</code> 包含 <code>B.h</code>，<code>B.h</code> 又包含 <code>A.h</code>，直接包含会导致编译报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 前向声明 B，而不是 #include &quot;B.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 只声明指针/引用，不需要 B 的完整定义</span></span><br><span class="line">    B* b_ptr; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(B&amp; b)</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 前向声明 A，而不是 #include &quot;A.h&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A* a_ptr;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A&amp; a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>减少编译依赖，加速编译</p><p>如果一个头文件只需要用到某个类的指针 / 引用，而不需要创建对象、调用成员函数，那么用前向声明替代 <code>#include</code>，可以避免引入整个头文件：</p><ul><li>比如 <code>#include &quot;Entity.h&quot;</code> 会把 <code>Entity</code> 的完整定义引入，编译时要处理更多代码；</li><li>而前向声明 <code>class Entity;</code> 只告诉编译器 “有这个类”，编译更快，且修改 <code>Entity</code> 的定义时，当前文件不需要重新编译。</li></ul></li></ol><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><strong>能用的场景</strong>：</p><ul><li>声明指向该类的指针 / 引用（<code>Entity* ptr;</code>、<code>Entity&amp; ref;</code>）；</li><li>作为函数的参数 / 返回值（<code>void func(Entity);</code>、<code>Entity getEntity();</code>）；</li></ul><p><strong>不能用的场景</strong>：</p><ul><li>创建该类的对象（<code>Entity e;</code> → 编译器需要知道类的大小，必须有完整定义）；</li><li>访问类的成员（<code>e.size;</code>、<code>e.func();</code> → 编译器需要知道成员的具体定义）；</li><li>继承该类（<code>class Derived : public Entity {};</code> → 必须知道基类的完整定义）。</li></ul><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存分区</title>
      <link href="/posts/14b8e558/"/>
      <url>/posts/14b8e558/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分区概念"><a href="#内存分区概念" class="headerlink" title="内存分区概念"></a>内存分区概念</h1><p>C++程序在运行时，内存通常被分为五大区域（代码、全局、常量、堆、栈），也可以简化为四个分区（代码、全局、堆、栈）。</p><h2 id="代码区（Code-Text-Segment）"><a href="#代码区（Code-Text-Segment）" class="headerlink" title="代码区（Code/Text Segment）"></a>代码区（Code/Text Segment）</h2><ul><li>存放程序（编译后）的机器指令</li><li>通常只读</li></ul><h2 id="全局区（Global-Area）"><a href="#全局区（Global-Area）" class="headerlink" title="全局区（Global Area）"></a>全局区（Global Area）</h2><ul><li>已初始化的全局/静态变量（Data段）</li><li>未初始化的全局/静态变量（BSS段）</li><li>全局常量、字符串常量（.rodata常量区）</li><li>生命周期：从程序开始到结束</li></ul><h2 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h2><ul><li>使用 <code>new</code> 或 <code>malloc</code> 动态分配</li><li>手动释放：<code>delete</code> / <code>free</code></li><li>生命周期由开发者管理</li></ul><h2 id="栈区（Stack）"><a href="#栈区（Stack）" class="headerlink" title="栈区（Stack）"></a>栈区（Stack）</h2><ul><li>用于局部变量、函数参数等</li><li>系统自动分配和释放</li><li>生命周期短暂，随函数调用进出</li></ul><hr><blockquote><p><a href="https://www.bilibili.com/video/BV1bwoRYJEXY?vd_source=59c9078be8272e804fcbbcf1da9a9f94">C++内存地图全解：变量到底藏在哪？ 高频面试内存分区精讲</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端和后端</title>
      <link href="/posts/fb005d31/"/>
      <url>/posts/fb005d31/</url>
      
        <content type="html"><![CDATA[<p>把整个互联网产品（网站 / APP / 小程序）比作<strong>一家线下超市</strong>：</p><p><strong>前端</strong>：超市的<strong>购物区</strong>（货架、收银台、导购员、购物车）—— 用户直接接触，负责<strong>视觉展示和交互体验</strong>，用户能看、能摸、能操作；</p><p><strong>后端</strong>：超市的<strong>仓库、后台办公室、物流系统、财务系统</strong>—— 用户完全接触不到，负责<strong>数据管理、业务规则、资源调度</strong>，支撑前端的所有操作；</p><p><strong>前后端的连接</strong>：超市的<strong>导购员喊仓库补货、收银台连财务系统</strong>—— 前端通过「约定的规则」向后端要数据 / 提需求，后端处理后反馈结果。</p><h1 id="一、前端开发：做-“用户能看见、能操作的一切”"><a href="#一、前端开发：做-“用户能看见、能操作的一切”" class="headerlink" title="一、前端开发：做 “用户能看见、能操作的一切”"></a>一、前端开发：做 “用户能看见、能操作的一切”</h1><h2 id="核心定位"><a href="#核心定位" class="headerlink" title="核心定位"></a>核心定位</h2><p><strong>用户侧的开发</strong>，核心目标是<strong>打造良好的视觉体验和流畅的交互逻辑</strong>，让用户能轻松、直观地使用产品，同时保证在不同设备（电脑、手机、平板）上都能正常显示和操作。</p><h2 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h2><ol><li><strong>运行位置</strong>：<strong>用户自己的设备</strong>（电脑浏览器、手机 APP / 小程序、平板），<strong>不占用服务器资源</strong>，代码由用户设备加载执行；</li><li><strong>交互对象</strong>：<strong>最终用户</strong>（直接和人打交道），偶尔通过网络和后端服务器通信；</li><li><strong>核心要求</strong>：<strong>美观、流畅、兼容、易用</strong>—— 比如按钮点了就有反应、手机上看页面不跑偏、网络差的时候也能正常显示基础内容。</li></ol><h2 id="前端的核心工作内容"><a href="#前端的核心工作内容" class="headerlink" title="前端的核心工作内容"></a>前端的核心工作内容</h2><p>前端开发不是单纯的 “做页面”，而是<strong>把设计稿变成可交互的产品，并保障体验</strong>，核心工作分 4 类：</p><ol><li><strong>界面搭建</strong>：把 UI 设计师的设计稿，用技术还原成可视化的页面（比如电商网站的商品列表、微信的聊天界面）；</li><li><strong>交互实现</strong>：处理用户的所有操作，比如点击按钮弹窗、下拉页面加载更多、输入框实时验证、滑动切换图片；</li><li><strong>多端适配</strong>：保证页面在不同设备、不同浏览器上显示一致（比如电脑上的淘宝和手机淘宝，内容一致但布局适配屏幕）；</li><li><strong>前端性能优化</strong>：让页面加载更快、操作更流畅（比如首屏加载控制在 3 秒内、点击按钮无延迟）。</li></ol><h2 id="核心技术体系"><a href="#核心技术体系" class="headerlink" title="核心技术体系"></a>核心技术体系</h2><p>前端的技术栈非常成熟，<strong>所有技术最终都围绕「HTML/CSS/JavaScript」三大核心</strong>，这是前端的 “地基”，其他都是基于这三者的封装和拓展。</p><div class="table-container"><table><thead><tr><th style="text-align:center">技术层级</th><th style="text-align:center">核心技术</th><th style="text-align:center">作用说明</th><th style="text-align:center">常用工具 / 框架</th></tr></thead><tbody><tr><td style="text-align:center">基础层（必学）</td><td style="text-align:center">HTML</td><td style="text-align:center">页面的「骨架」，定义页面有什么内容（标题、按钮、图片、列表）</td><td style="text-align:center">纯 HTML5（主流）</td></tr><tr><td style="text-align:center">基础层（必学）</td><td style="text-align:center">CSS</td><td style="text-align:center">页面的「皮肤」，定义页面的样式（颜色、大小、布局、动画）</td><td style="text-align:center">CSS3、Flex/Grid（布局）、Less/Sass（CSS 预处理器）</td></tr><tr><td style="text-align:center">基础层（必学）</td><td style="text-align:center">JavaScript（JS）</td><td style="text-align:center">页面的「大脑」，定义页面的交互逻辑（点击、滑动、请求数据）</td><td style="text-align:center">ES6+（JS 最新语法）</td></tr><tr><td style="text-align:center">框架层（主流）</td><td style="text-align:center">前端框架</td><td style="text-align:center">封装了常用的 JS/CSS 逻辑，大幅提升开发效率，适合中大型项目</td><td style="text-align:center">Vue3（易上手）、React（灵活，大厂常用）、Angular（全能型，外企 / 大厂）</td></tr><tr><td style="text-align:center">工程化</td><td style="text-align:center">构建工具</td><td style="text-align:center">管理前端项目的代码、依赖、打包，让开发更规范</td><td style="text-align:center">Vite（新一代，快）、Webpack（经典，成熟）</td></tr><tr><td style="text-align:center">多端开发</td><td style="text-align:center">跨端框架</td><td style="text-align:center">一套代码适配多个平台（手机 APP、小程序、H5），减少重复开发</td><td style="text-align:center">UniApp、Taro（适配小程序 / APP）、Flutter（跨端原生，偏客户端）</td></tr><tr><td style="text-align:center">辅助工具</td><td style="text-align:center">调试 / 规范</td><td style="text-align:center">保障代码质量和开发效率</td><td style="text-align:center">Chrome 开发者工具、Eslint（代码规范）、Prettier（代码格式化）</td></tr></tbody></table></div><h1 id="二、后端开发：做-“用户看不见、但支撑一切的核心逻辑”"><a href="#二、后端开发：做-“用户看不见、但支撑一切的核心逻辑”" class="headerlink" title="二、后端开发：做 “用户看不见、但支撑一切的核心逻辑”"></a>二、后端开发：做 “用户看不见、但支撑一切的核心逻辑”</h1><h2 id="核心定位-1"><a href="#核心定位-1" class="headerlink" title="核心定位"></a>核心定位</h2><p><strong>服务器侧的开发</strong>，核心目标是<strong>保障产品的业务逻辑正确、数据安全、系统稳定、性能达标</strong>，简单说就是 “前端提什么需求，后端就按规则处理，并且把结果返给前端”，同时管理所有产品数据。</p><h2 id="关键特征-1"><a href="#关键特征-1" class="headerlink" title="关键特征"></a>关键特征</h2><ol><li><strong>运行位置</strong>：<strong>远程的服务器</strong>（阿里云 / 腾讯云等云服务器，或公司自建服务器），代码永远在服务器上运行，用户设备无法直接访问；</li><li><strong>交互对象</strong>：<strong>前端服务器、数据库、中间件、其他第三方服务</strong>（比如微信支付、短信接口），<strong>不直接和用户打交道</strong>；</li><li><strong>核心要求</strong>：<strong>安全、稳定、高效、可扩展</strong>—— 比如用户登录密码不泄露、双 11 电商系统不崩溃、百万用户同时访问不卡顿、产品升级时不影响现有功能。</li></ol><h2 id="后端的核心工作内容"><a href="#后端的核心工作内容" class="headerlink" title="后端的核心工作内容"></a>后端的核心工作内容</h2><p>后端开发的核心是<strong>处理 “数据” 和 “逻辑”</strong>，所有工作都围绕「接收请求→处理逻辑→操作数据→返回结果」这个核心流程，具体分 6 类：</p><ol><li><strong>接口开发</strong>：开发前后端沟通的「API 接口」（约定好的地址和数据格式），这是前后端唯一的沟通桥梁，比如 “登录接口”“获取商品列表接口”“下单接口”；</li><li><strong>业务逻辑处理</strong>：实现产品的核心规则，比如登录时验证账号密码是否正确、下单时扣减商品库存并生成订单、充值时对接支付接口并更新账户余额；</li><li><strong>数据层操作</strong>：管理所有产品数据，包括<strong>数据库的增删改查</strong>（比如存储用户信息、查询商品数据、删除订单）、数据备份、数据同步；</li><li><strong>服务器与部署</strong>：把后端代码部署到云服务器，配置服务器环境（比如安装 Java/Python 运行环境），保障服务器 7×24 小时运行；</li><li><strong>安全防护</strong>：防止黑客攻击，保障数据安全，比如防止密码泄露（加密存储）、防止恶意请求（接口限流）、防止 SQL 注入（数据库攻击）、验证用户身份（token / 会话）；</li><li><strong>性能与高并发优化</strong>：让系统能支撑更多用户同时访问，比如加入缓存（Redis）减少数据库压力、做分布式部署（多台服务器同时工作）、优化代码执行效率。</li></ol><h2 id="后端的核心技术体系（「编程语言-框架」是核心，其余是必备配套技术）"><a href="#后端的核心技术体系（「编程语言-框架」是核心，其余是必备配套技术）" class="headerlink" title="后端的核心技术体系（「编程语言 + 框架」是核心，其余是必备配套技术）"></a>后端的核心技术体系（「编程语言 + 框架」是核心，其余是必备配套技术）</h2><p>后端技术栈是一个<strong>完整的生态体系</strong>，编程语言只是 “工具”，必须配合框架、数据库、服务器、中间件等才能完成开发，核心体系分 5 类，且不同编程语言对应不同的主流框架（按需选择）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">技术层级</th><th style="text-align:center">核心作用</th><th style="text-align:center">主流技术 / 工具</th><th style="text-align:center">搭配说明</th></tr></thead><tbody><tr><td style="text-align:center">核心层（语言 + 框架）</td><td style="text-align:center">实现业务逻辑和接口开发</td><td style="text-align:center">语言：Java、Python、Go、PHP、C++框架：SpringBoot（Java）、Django/FastAPI（Python）、Gin（Go）、Laravel（PHP）</td><td style="text-align:center">框架封装了通用逻辑，比如 Java+SpringBoot 是目前最主流的后端组合，开发效率高、生态完善</td></tr><tr><td style="text-align:center">数据层（数据库）</td><td style="text-align:center">存储和管理所有产品数据</td><td style="text-align:center">关系型：MySQL（主流）、PostgreSQL（功能强）、Oracle（大型企业）非关系型：Redis（缓存，必用）、MongoDB（存非结构化数据，比如图片 / 文章）、Elasticsearch（搜索引擎）</td><td style="text-align:center">关系型数据库存结构化数据（用户信息、订单），非关系型数据库做补充，Redis 几乎是所有后端项目的标配</td></tr><tr><td style="text-align:center">服务器层</td><td style="text-align:center">接收前端请求，转发给后端程序</td><td style="text-align:center">Nginx（主流，反向代理 + 静态资源服务）、Tomcat（Java 专属）、Apache（经典）</td><td style="text-align:center">Nginx 是必备，负责做 “流量入口”，比如把用户的请求转发给对应的后端接口</td></tr><tr><td style="text-align:center">中间件层</td><td style="text-align:center">提升系统性能、可扩展性，解决分布式问题</td><td style="text-align:center">缓存：Redis消息队列：Kafka/RabbitMQ（削峰填谷，比如双 11 下单）服务注册：Nacos/Eureka（分布式部署用）</td><td style="text-align:center">中间件是后端 “进阶” 的关键，中小型项目至少用 Redis，大型项目会用到多种中间件</td></tr><tr><td style="text-align:center">运维 / 部署</td><td style="text-align:center">保障服务器和代码正常运行</td><td style="text-align:center">Docker（容器化，环境一致）、K8s（容器编排）、Jenkins（自动化部署）、Linux（服务器系统，必学）</td><td style="text-align:center">后端开发必须懂基础的 Linux 和 Docker，这是部署代码的前提</td></tr></tbody></table></div><h1 id="三、前后端的核心协作逻辑：通过「API-接口」通信"><a href="#三、前后端的核心协作逻辑：通过「API-接口」通信" class="headerlink" title="三、前后端的核心协作逻辑：通过「API 接口」通信"></a>三、前后端的核心协作逻辑：通过「API 接口」通信</h1><p>互联网开发的<strong>主流模式是「前后端分离」—— 前端和后端是两个独立的项目，各自开发、各自部署，</strong>唯一的沟通方式就是「API 接口」**，这和早期 “前后端耦合（代码写在一起）” 的模式完全不同，也是现在大厂、中小企业的标配。</p><h2 id="「接口约定」"><a href="#「接口约定」" class="headerlink" title="「接口约定」"></a>「接口约定」</h2><p>为了避免沟通混乱，前端和后端在开发前会<strong>约定好 API 的所有规则</strong>，并形成文档（常用工具：Swagger、Yapi、Apifox），约定的内容包括：</p><ul><li>接口地址（比如<code>/api/login</code>）；</li><li>请求方式（比如 GET：查询数据 / POST：提交数据 / PUT：修改数据 / DELETE：删除数据）；</li><li>请求参数（比如账号、密码，包括参数名、类型、是否必传）；</li><li>返回数据（比如成功的返回格式、失败的返回格式，包括字段名、类型）；</li><li>错误码（比如 200 = 成功、400 = 参数错误、401 = 未登录、500 = 服务器内部错误）。</li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数签名</title>
      <link href="/posts/b332b12e/"/>
      <url>/posts/b332b12e/</url>
      
        <content type="html"><![CDATA[<p>函数签名决定函数是否相同。</p><p>函数签名：</p><ul><li>函数名</li><li>参数类型列表</li><li>cv限定符——const 和 volatile</li><li>引用限定符（&amp; 和 &amp;&amp;）</li></ul><p>虚函数的重写需要完全匹配</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu中安装配置anaconda</title>
      <link href="/posts/92674cb2/"/>
      <url>/posts/92674cb2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>环境：Ubuntu20.04</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>从<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>网站中下载所需要的软件包</p><p>以<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2024.06-1-Linux-x86_64.sh" title="Anaconda3-2024.06-1-Linux-x86_64.sh">Anaconda3-2024.06-1-Linux-x86_64.sh</a>为例</p><p>下载到想要安装的文件夹下:[~/software/anaconda3（我的位置）]（需要替换成你的位置）</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>ctl+alt+T 打开终端进入该文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cd</span> [~/software/anaconda3（我的位置）]</span></span><br><span class="line">[~/software/anaconda3（我的位置）]$ bash Anaconda3-2024.06-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>不断回车，需要输入就输入yes</p><p>中途会需要选择安装目录</p><p><img src="/images/Blog/Ubuntu软件安装/1.png" alt=""></p><ul><li><p>Enter 默认在用户主目录下创建一个名为anaconda3的文件夹作为安装地址</p></li><li><p>我是输入 <code>/home/software/anaconda3</code> 安装在这个目录下</p></li></ul><p>安装成功：<br><img src="/images/Blog/Ubuntu软件安装/2.png" alt=""></p><h3 id="查看安装的包"><a href="#查看安装的包" class="headerlink" title="查看安装的包"></a>查看安装的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base)[~/software/anaconda3（我的位置）]$ conda list</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(base)[~/software/anaconda3（我的位置）]$ cd ~</span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash">vim .bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="string">&#x27;conda init&#x27;</span> !!</span></span><br><span class="line">__conda_setup=&quot;$(&#x27;[~/software/anaconda3（我的位置）]/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;[~/software/anaconda3（我的位置）]/etc/profile.d/conda.sh&quot; ]; then</span><br><span class="line">        . &quot;/home/leon/software/anaconda3/etc/profile.d/conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH=&quot;[~/software/anaconda3（我的位置）]/bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="string">conda initialize &lt;&lt;&lt;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">或者直接在根目录下 ctl+h 找到隐藏文件.bashrc添加以上内容</span></span></span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="string">source ~/.bashrc   # 使环境变量更改生效。</span></span></span><br></pre></td></tr></table></figure><h2 id="创建应用桌面图标"><a href="#创建应用桌面图标" class="headerlink" title="创建应用桌面图标"></a>创建应用桌面图标</h2><h3 id="创建图标文件"><a href="#创建图标文件" class="headerlink" title="创建图标文件"></a>创建图标文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">cd</span> .<span class="built_in">local</span>/share/applications</span></span><br></pre></td></tr></table></figure><blockquote><p><code>~/.local/share/applications</code>:用于存储当前用户的桌面应用程序相关信息。这个目录中的 <code>.desktop</code> 文件包含了用户特定的应用程序启动配置，例如应用程序的名称、图标、执行命令等。这些文件仅对当前用户有效，其他用户无法访问或影响这些配置。</p><p><code>/usr/share/applications/</code>:目录用于存储系统范围内的桌面应用程序配置文件。这些文件是针对所有用户的，因此无论哪个用户登录，都会看到这些应用程序。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base)~/.local/share/applications$ vim anaconda.desktop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">----------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=Anaconda</span><br><span class="line">Version=2.5.2</span><br><span class="line">Type=Application</span><br><span class="line">Exec=[~/software/anaconda3（我的位置）]/bin/anaconda-navigator</span><br><span class="line">Icon=[~/software/anaconda3（我的位置）]/pkgs/anaconda-navigator-2.5.2-py311h06a4308_0/lib/python3.11/site-packages/anaconda_navigator/app/icons/Icon1024.png</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-----------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出</span></span><br></pre></td></tr></table></figure><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base)~/.local/share/applications$ sudo chmod a+x anaconda.desktop</span><br></pre></td></tr></table></figure><h2 id="修改Anaconda镜像"><a href="#修改Anaconda镜像" class="headerlink" title="修改Anaconda镜像"></a>修改Anaconda镜像</h2><p>由于外网限制，Anaconda 下载安装包很慢，可以使用国内镜像提高安装包下载速度。</p><p>清华镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure><h3 id="修改镜像："><a href="#修改镜像：" class="headerlink" title="修改镜像："></a>修改镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br></pre></td></tr></table></figure><h3 id="设置下载安装包显示源路径（可选）："><a href="#设置下载安装包显示源路径（可选）：" class="headerlink" title="设置下载安装包显示源路径（可选）："></a>设置下载安装包显示源路径（可选）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h3 id="查看："><a href="#查看：" class="headerlink" title="查看："></a>查看：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conda config --show</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看到channels： xxx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cat</span> ./.condarc</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示：</span></span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br></pre></td></tr></table></figure><h3 id="删除指定源"><a href="#删除指定源" class="headerlink" title="删除指定源"></a>删除指定源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels XXX</span><br></pre></td></tr></table></figure><h3 id="还原源文件"><a href="#还原源文件" class="headerlink" title="还原源文件"></a>还原源文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><h2 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; python=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建一个名为 &quot;myenv&quot;，Python 版本为 3.9 的环境</span></span><br><span class="line"></span><br><span class="line">conda create -n myenv python=3.9</span><br></pre></td></tr></table></figure><h4 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：激活名为 &quot;myenv&quot; 的环境</span></span><br><span class="line"></span><br><span class="line">conda activate myenv</span><br></pre></td></tr></table></figure><h4 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n &lt;环境名&gt; --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：删除名为 &quot;myenv&quot; 的环境</span></span><br><span class="line">conda remove -n myenv --all</span><br></pre></td></tr></table></figure><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：安装 numpy</span></span><br><span class="line"></span><br><span class="line">conda install numpy</span><br></pre></td></tr></table></figure><h4 id="指定版本安装包"><a href="#指定版本安装包" class="headerlink" title="指定版本安装包"></a>指定版本安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install &lt;包名&gt;=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：安装 numpy 的 1.21.0 版本</span></span><br><span class="line"></span><br><span class="line">conda install numpy=1.21.0</span><br></pre></td></tr></table></figure><h4 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda update &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：更新 numpy 到最新版本</span></span><br><span class="line"></span><br><span class="line">conda update numpy</span><br></pre></td></tr></table></figure><h4 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda remove &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：删除 numpy</span></span><br><span class="line"></span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h4 id="查看已有环境"><a href="#查看已有环境" class="headerlink" title="查看已有环境"></a>查看已有环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><h4 id="查看已安装的包"><a href="#查看已安装的包" class="headerlink" title="查看已安装的包"></a>查看已安装的包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定包的信息</span></span><br><span class="line"></span><br><span class="line">conda list &lt;包名&gt;</span><br></pre></td></tr></table></figure><h3 id="环境导出与还原"><a href="#环境导出与还原" class="headerlink" title="环境导出与还原"></a>环境导出与还原</h3><h4 id="导出环境"><a href="#导出环境" class="headerlink" title="导出环境"></a>导出环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> &gt; environment.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前环境导出到 environment.yml 文件</span></span><br></pre></td></tr></table></figure><h4 id="从文件创建环境"><a href="#从文件创建环境" class="headerlink" title="从文件创建环境"></a>从文件创建环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> create -f environment.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 environment.yml 文件创建环境</span></span><br></pre></td></tr></table></figure><h4 id="environment-yml文件"><a href="#environment-yml文件" class="headerlink" title="environment.yml文件"></a>environment.yml文件</h4><p>用来管理和分享 Conda 环境的配置文件。定义了一个环境的名称、依赖包及其版本，方便用户快速创建、重现或共享环境。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="comment"># 定义环境的名字，如果没有 prefix:，Conda 会根据 name 将环境创建在默认路径下，通常是 &lt;conda安装路径&gt;/envs/&lt;name&gt;。</span></span><br><span class="line"><span class="attr">channels:</span> <span class="comment"># 指定安装依赖时使用的 Conda 仓库（渠道）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">dependencies:</span> <span class="comment"># 列出该环境所需的依赖包及其版本</span></span><br><span class="line">  <span class="bullet">-</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pip:</span> <span class="comment"># pip 下列出的包会通过 pip 而不是 Conda 安装</span></span><br><span class="line">    <span class="bullet">-</span> </span><br><span class="line"><span class="attr">prefix:</span> <span class="comment"># 指定环境的具体路径（绝对路径）。如果有 prefix: 字段，Conda 会忽略 name:，直接将环境安装到指定位置。对于跨系统使用，建议删除此字段以避免路径不兼容。</span></span><br></pre></td></tr></table></figure><h4 id="克隆环境"><a href="#克隆环境" class="headerlink" title="克隆环境"></a>克隆环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;新环境名&gt; --<span class="built_in">clone</span> &lt;已有环境名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：克隆 &quot;myenv&quot; 环境为 &quot;newenv&quot;</span></span><br><span class="line"></span><br><span class="line">conda create --name newenv --<span class="built_in">clone</span> myenv</span><br></pre></td></tr></table></figure><h3 id="Conda-更新与清理"><a href="#Conda-更新与清理" class="headerlink" title="Conda 更新与清理"></a>Conda 更新与清理</h3><h4 id="更新-Conda-本身"><a href="#更新-Conda-本身" class="headerlink" title="更新 Conda 本身"></a>更新 Conda 本身</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h4 id="更新所有包"><a href="#更新所有包" class="headerlink" title="更新所有包"></a>更新所有包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure><h4 id="清理-Conda-缓存"><a href="#清理-Conda-缓存" class="headerlink" title="清理 Conda 缓存"></a>清理 Conda 缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda clean --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项说明：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --all：清除所有冗余文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --packages：清除未使用的包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --tarballs：清除下载的压缩包</span></span><br></pre></td></tr></table></figure><h3 id="创建基于特定-Python-版本的环境"><a href="#创建基于特定-Python-版本的环境" class="headerlink" title="创建基于特定 Python 版本的环境"></a>创建基于特定 Python 版本的环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; python=&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：创建一个 Python 3.8 的环境</span></span><br><span class="line"></span><br><span class="line">conda create -n py38 python=3.8</span><br></pre></td></tr></table></figure><h3 id="管理-Conda-虚拟环境中的-Pip"><a href="#管理-Conda-虚拟环境中的-Pip" class="headerlink" title="管理 Conda 虚拟环境中的 Pip"></a>管理 Conda 虚拟环境中的 Pip</h3><p>如果需要使用 <code>pip</code> 安装包，请在 Conda 环境中使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install pip</span><br><span class="line"></span><br><span class="line">pip install &lt;包名&gt;</span><br></pre></td></tr></table></figure><h2 id="删除anaconda"><a href="#删除anaconda" class="headerlink" title="删除anaconda"></a>删除anaconda</h2><h3 id="删除相应的文件夹及文件"><a href="#删除相应的文件夹及文件" class="headerlink" title="删除相应的文件夹及文件"></a>删除相应的文件夹及文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">cd</span> [~/software（我的位置）]</span></span><br><span class="line">(base)[~/software（我的位置）]$ rm -rf anaconda3   # 删除所安装的目录文件夹</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作是彻底删除</span></span><br><span class="line">(base)[~/software（我的位置）]$ cd ~</span><br><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash"><span class="built_in">rm</span> -rf ~/.anaconda ~/.conda</span></span><br></pre></td></tr></table></figure><h3 id="删除anaconda环境变量"><a href="#删除anaconda环境变量" class="headerlink" title="删除anaconda环境变量"></a>删除anaconda环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(base)~$ </span><span class="language-bash">vim .bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!! Contents within this block are managed by <span class="string">&#x27;conda init&#x27;</span> !!</span></span><br><span class="line">__conda_setup=&quot;$(&#x27;[~/software/anaconda3（我的位置）]/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;[~/software/anaconda3（我的位置）]/etc/profile.d/conda.sh&quot; ]; then</span><br><span class="line">        . &quot;/home/leon/software/anaconda3/etc/profile.d/conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH=&quot;[~/software/anaconda3（我的位置）]/bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt; <span class="string">conda initialize &lt;&lt;&lt;</span></span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://blog.csdn.net/thy0000/article/details/122878599">Ubuntu安装Anaconda详细步骤（Ubuntu21.10，Anaconda3）</a></p><p><a href="https://blog.csdn.net/KIK9973/article/details/118795049">Unbuntu卸载anaconda(最新最全亲测)_ubuntu卸载anaconda</a></p><p>[Ubuntu——Anaconda环境配置及镜像修改_ubuntu 修改conda镜像-CSDN博客](</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu软件安装 </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu中conda安装显卡驱动、CUDA、pytorch</title>
      <link href="/posts/93149687/"/>
      <url>/posts/93149687/</url>
      
        <content type="html"><![CDATA[<blockquote><p>环境：Ubuntu20.04 x86_64、 anaconda</p></blockquote><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><blockquote><p>显卡驱动（GPU driver）是操作系统与显卡硬件之间的一种软件接口，它负责管理和控制计算机中的图形处理器（GPU），<mark>是一种底层软件</mark>。显卡驱动的主要作用是使操作系统和应用程序能够正确使用显卡的硬件资源，从而处理和显示图形、加速渲染和视频输出等任务。</p><p>显卡驱动的主要功能：</p><ol><li><p><strong>与硬件通信</strong>：<br>显卡驱动是显卡硬件与操作系统之间的“桥梁”。它向操作系统提供一套标准化的指令，使操作系统能够利用显卡硬件执行图形任务，比如 3D 渲染、视频解码等。</p></li><li><p><strong>图形加速</strong>：<br>显卡驱动通过调用 GPU 的硬件加速功能，显著提升图形渲染性能，尤其是对 3D 应用程序和视频的处理。它能够将复杂的图形任务交给 GPU 专门的硬件来执行，而不是让 CPU 完全负责。</p></li><li><p><strong>显示设置和管理</strong>：<br>驱动程序管理和控制显示器的分辨率、刷新率、颜色深度等参数，并支持多显示器配置。在驱动程序中，你可以调整显示器的布局、旋转方向等。</p></li><li><p><strong>优化性能</strong>：<br>显卡驱动通常会根据具体硬件做优化，使得系统能够以最高效的方式使用显卡的资源。制造商（如 NVIDIA 或 AMD）会发布驱动更新，修复问题或优化针对特定游戏、软件的性能。</p></li><li><p><strong>兼容性</strong>：<br>驱动程序确保操作系统与显卡硬件的兼容性，提供 API（如 OpenGL、DirectX、Vulkan）的支持，允许开发人员编写图形应用程序，并且让用户能够运行这些应用程序。</p></li></ol><p>常见的显卡驱动类型：</p><ol><li><p><strong>厂商驱动（Proprietary Drivers）</strong>：<br>这些是由显卡制造商（如 NVIDIA、AMD 或 Intel）开发并发布的专有驱动程序。它们通常是闭源的，性能优化和硬件支持更好，尤其是在处理图形密集型任务（如游戏、3D 渲染）时表现更佳。</p><ul><li>例如：NVIDIA 的 <code>nvidia-driver-535</code>、AMD 的 <code>amdgpu-pro</code>。</li></ul></li><li><p><strong>开源驱动（Open-Source Drivers）</strong>：<br>开源社区为某些显卡开发了免费的驱动程序，它们是开源的，可以由用户修改和改进。尽管这些驱动程序的性能有时不如厂商的闭源驱动，但它们在开源操作系统（如 Linux）中使用广泛，并且由社区进行长期维护。</p><ul><li>例如：NVIDIA 的开源驱动 <code>nouveau</code>、AMD 的 <code>amdgpu</code>。</li></ul></li></ol></blockquote><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa  <span class="comment"># 加入官方ppa源</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt update  <span class="comment"># 检查软件包更新列表</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt upgrade  <span class="comment"># 更新所有可更新的软件包</span></span></span><br></pre></td></tr></table></figure><h3 id="检查可选驱动"><a href="#检查可选驱动" class="headerlink" title="检查可选驱动"></a>检查可选驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">ubuntu-drivers devices</span> </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我的结果：</span><br><span class="line">ubuntu-drivers devices</span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00002560sv000017AAsd00003AE8bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">driver   : nvidia-driver-470 - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535-server-open - distro non-free</span><br><span class="line">driver   : nvidia-driver-470-server - distro non-free</span><br><span class="line">driver   : nvidia-driver-535 - distro non-free recommended</span><br><span class="line">driver   : nvidia-driver-535-open - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free builtin</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><strong>distro</strong>: 代表你的 Linux 发行版（distribution），例如 Ubuntu。它指明这个驱动程序是由发行版的官方软件仓库提供的，而不是用户手动从第三方下载的。</p></li><li><p><strong>non-free</strong>: 代表该驱动程序是 <strong>非自由</strong>（proprietary）的，也就是它的源代码没有公开，通常由公司（如 NVIDIA）拥有和维护。用户无法自由修改或发布它的源代码。虽然它是闭源的，但通常能够提供更好的硬件支持、性能优化和 bug 修复。</p></li></ul><ol><li><p><strong>nvidia-driver-535 (推荐)</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: NVIDIA 专有驱动（non-free）</li><li><strong>描述</strong>: 这是最新的稳定版本，由 NVIDIA 官方提供。它被推荐用于现代 NVIDIA 显卡，支持最新的显卡功能、性能优化和 bug 修复。如果系统推荐你使用这个驱动，意味着它最适合你的显卡硬件。</li></ul></li><li><p><strong>nvidia-driver-535-open</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 开源版本</li><li><strong>描述</strong>: 这是 NVIDIA 的开源驱动，基于官方的 open-gpu-kernel-modules。尽管它是开源的，但在功能和性能上可能不如闭源版本全面，适合希望在开源环境中使用的用户。</li></ul></li><li><p><strong>nvidia-driver-535-server</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是专门为服务器硬件优化的版本。服务器驱动专注于稳定性和长期支持，通常被用于数据中心和 GPU 加速的计算任务，如深度学习、AI 推理等工作负载。</li></ul></li><li><p><strong>nvidia-driver-535-server-open</strong>：</p><ul><li><strong>版本</strong>: 535</li><li><strong>类型</strong>: 开源版本</li><li><strong>描述</strong>: 这是服务器驱动的开源版本，类似于 <code>nvidia-driver-535-open</code>，但针对服务器工作负载进行了优化。</li></ul></li><li><p><strong>nvidia-driver-470</strong>：</p><ul><li><strong>版本</strong>: 470</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是 NVIDIA 的较旧的稳定版本，适用于一些兼容性要求较高的旧显卡或软件环境。如果某些旧应用或旧硬件不完全支持新驱动，可能需要这个版本。</li></ul></li><li><p><strong>nvidia-driver-470-server</strong>：</p><ul><li><strong>版本</strong>: 470</li><li><strong>类型</strong>: 专有驱动（non-free）</li><li><strong>描述</strong>: 这是与 <code>nvidia-driver-470</code> 相似的版本，但它是为服务器环境优化的，重点关注稳定性和长期支持。</li></ul></li><li><p><strong>xserver-xorg-video-nouveau</strong>：</p><ul><li><strong>版本</strong>: Nouveau（开源驱动）</li><li><strong>类型</strong>: 开源驱动（free builtin）</li><li><strong>描述</strong>: 这是 Linux 社区开发的开源 NVIDIA 显卡驱动，默认包含在大多数 Linux 发行版中。虽然它不需要安装非自由软件，但性能和功能性不如 NVIDIA 的官方闭源驱动。适合对开源驱动有偏好，但在性能和显卡高级功能需求较低的场景。</li></ul></li></ol></blockquote><h3 id="下载安装驱动"><a href="#下载安装驱动" class="headerlink" title="下载安装驱动"></a>下载安装驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install nvidia-driver-535   <span class="comment"># 根据自己需求可选驱动下载显卡驱动</span></span></span><br></pre></td></tr></table></figure><h3 id="查看显卡基本信息验证是否安装成功"><a href="#查看显卡基本信息验证是否安装成功" class="headerlink" title="查看显卡基本信息验证是否安装成功"></a>查看显卡基本信息验证是否安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">nvidia-smi</span></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Ubuntu软件安装/3.png" alt=""></p><h3 id="查询问题（若未安装成功）"><a href="#查询问题（若未安装成功）" class="headerlink" title="查询问题（若未安装成功）"></a>查询问题（若未安装成功）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> gpu-manager</span></span><br></pre></td></tr></table></figure><p><img src="/images/Blog/Ubuntu软件安装/4.png" alt=""></p><p>根据信息进行相应问题解决</p><h2 id="CUDA安装（以下是安装在系统）"><a href="#CUDA安装（以下是安装在系统）" class="headerlink" title="CUDA安装（以下是安装在系统）"></a>CUDA安装（以下是安装在系统）</h2><blockquote><p>CUDA（Compute Unified Device Architecture）是由 <strong>NVIDIA</strong> 开发的<mark>一种并行计算平台和编程模型</mark>，旨在利用 <strong>GPU</strong>（图形处理单元）的强大计算能力进行通用计算任务。CUDA 允许开发者使用 GPU 处理不仅限于图形渲染的高性能计算任务，比如科学计算、机器学习、深度学习和模拟仿真等。</p><p><strong>CUDA的基本概念</strong></p><ol><li><p><strong>并行计算</strong>：<br>CUDA 提供了一种并行编程环境，允许开发者编写程序，将计算任务分解为大量的小任务，并将这些任务分配到 GPU 上的成千上万个处理核心上同时执行。GPU 的设计使得它非常适合处理需要大规模并行计算的任务。</p></li><li><p><strong>GPU与CPU的协作</strong>：<br>在 CUDA 编程中，CPU 称为 <strong>主机（Host）</strong>，GPU 则称为 <strong>设备（Device）</strong>。CPU 主要负责一般的计算任务和管理程序的控制流，而 GPU 则负责执行计算密集型的并行任务。CUDA 编程模型允许开发者将部分工作交给 GPU 处理，从而大大加速计算过程。</p></li><li><p><strong>内存模型</strong>：<br>CUDA 提供了灵活的内存管理方式。内存主要分为 <strong>主机内存（Host Memory）</strong> 和 <strong>设备内存（Device Memory）</strong>，即 CPU 和 GPU 各自的内存。程序通常需要将数据从主机内存复制到设备内存，然后在 GPU 上进行计算，最后将结果返回到主机。</p></li></ol><p><strong>CUDA 编程模型</strong></p><p>CUDA 的编程语言基于 <strong>C/C++</strong>，并提供了扩展来定义并行任务，主要包括以下几个核心概念：</p><ol><li><p><strong>核函数（Kernel Function）</strong>：<br>核函数是运行在 GPU 上的函数。每个核函数通过大量的线程并行运行。CUDA 的并行模型允许开发者将计算任务划分为多个线程，所有线程可以同时执行核函数。</p></li><li><p><strong>线程（Thread）</strong>：<br>CUDA 中的每个线程是执行核函数的基本单位。数以千计的线程能够被 GPU 并行运行，从而大大提高运算效率。CUDA 线程组织在多个层次的结构中，如 <strong>线程块（Block）</strong> 和 <strong>网格（Grid）</strong>。</p></li><li><p><strong>线程块（Block）</strong> 和 <strong>网格（Grid）</strong>：</p><ul><li><strong>线程块</strong>：一组线程被组织成线程块。每个线程块中的线程可以共享一些本地的设备内存，并且可以进行同步操作。一个线程块最多可以包含 1024 个线程。</li><li><strong>网格</strong>：多个线程块组成一个网格。网格中的线程块可以独立运行，因此 CUDA 可以将庞大的计算任务分解到成千上万个线程块中。</li></ul></li></ol></blockquote><h3 id="查看对应版本"><a href="#查看对应版本" class="headerlink" title="查看对应版本"></a>查看对应版本</h3><p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">查询链接</a>中根据自己显卡版本选择合适的CUDA版本</p><p><img src="/images/Blog/Ubuntu软件安装/5.png" alt=""></p><p><img src="/images/Blog/Ubuntu软件安装/6.png" alt=""></p><p><code>nvidia-smi</code>查询驱动版本，我的驱动版本 <code>Driver Version: 535.183.01</code>，可以安装 CUDA Version 12.2</p><h3 id="下载CUDA"><a href="#下载CUDA" class="headerlink" title="下载CUDA"></a>下载CUDA</h3><p>到官网(<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a>)根据自己的需要选择CUDA版本</p><p><img src="/images/Blog/Ubuntu软件安装/7.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">wget https://developer.download.nvidia.com/compute/cuda/12.2.2/local_installers/cuda_12.2.2_535.104.05_linux.run</span></span><br></pre></td></tr></table></figure><h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> sh cuda_12.2.2_535.104.05_linux.run</span></span><br></pre></td></tr></table></figure><ol><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6dc85544475499997e8606ed30ee875a.png" alt=""></p></li><li><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8eda00e88164002cb3ea78c2efcf45a7.png" alt=""></p></li><li><p>选择驱动，给他回车取消，因为我们已经有安装驱动了，然后移动到install安装<img src="https://i-blog.csdnimg.cn/blog_migrate/88b5eea6fad323b3c180aad8c14801f3.png" alt=""></p></li></ol><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">sudo</span> vim ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt;<span class="string">cuda&lt;&lt;&lt;</span></span></span><br><span class="line">export PATH=&quot;/usr/local/cuda-12.1/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/usr/local/cuda-12.1/lib64:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc    <span class="comment"># 更新环境变量</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">nvcc -V</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我的输出：</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2023 NVIDIA Corporation</span><br><span class="line">Built on Mon_Apr__3_17:16:06_PDT_2023</span><br><span class="line">Cuda compilation tools, release 12.1, V12.1.105</span><br><span class="line">Build cuda_12.1.r12.1/compiler.32688072_0</span><br></pre></td></tr></table></figure><h2 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h2><h3 id="选择合适pytorch版本"><a href="#选择合适pytorch版本" class="headerlink" title="选择合适pytorch版本"></a>选择合适pytorch版本</h3><p><a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>选择需要的版本</p><p><img src="/images/Blog/Ubuntu软件安装/8.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以创建虚拟环境,装在这个虚拟环境中</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">conda create --name pytorch_env python=3.11</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">conda activate pytorch_env</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CUDA 12.1</span></span><br><span class="line"><span class="meta prompt_">(pytorch_env)~$ </span><span class="language-bash">conda install pytorch==2.3.1 torchvision==0.18.1 torchaudio==2.3.1 pytorch-cuda=12.1 -c pytorch -c nvidia</span></span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(pytorch_env)~$ </span><span class="language-bash">python -c <span class="string">&quot;import torch; print(torch.__version__)&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出对应版本则成功： 2.3.1</span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://blog.csdn.net/qq_34972053/article/details/127689332">【ubuntu环境配置】超详细ubuntu20.04/22.04安装nvidia驱动/CUDA/cudnn_ubuntu20安装nvidia显卡驱动-CSDN博客</a></p><p>[Ubuntu 20.04安装显卡驱动、CUDA、Miniconda和Pytorch（2024.09最新）-Ubuntu从零搭建深度学习环境_ubuntu20.04安装显卡驱动-CSDN博客](</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu环境配置 </tag>
            
            <tag> pytorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/posts/2e3b1176/"/>
      <url>/posts/2e3b1176/</url>
      
        <content type="html"><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>马铃薯削成丝再变成薯饼（hash browns）：“无限多 —&gt; 固定” 的过程称为 Hashing（哈希）</p><p>无限的字符 —Hashing—&gt; 有限的数字 </p><p>哈希不可逆，加密可逆</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表通过键值对的形式实现。python中的字典是哈希表的一种实现形式。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在内存中是<strong>一块连续的、固定大小的内存空间</strong>，每个元素占用的内存大小相同，可以通过索引找到内存地址。访问 <code>arr[i]</code> 时，CPU 不需要遍历、不需要查表，直接通过公式算出元素的物理内存地址，然后读取 / 写入数据 —— 数组访问效率是 O (1) ；<strong>数组索引是内存地址的 “偏移量”</strong>，索引和内存地址是线性映射关系</p><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表（Hash Table）的<strong>物理存储载体是数组</strong>（也叫 “桶数组”），但它在数组的基础上增加了 “哈希函数映射” 和 “哈希碰撞处理” 两层逻辑，是 “数组 + 哈希函数 + 碰撞解决” 的组合体。</p><p>哈希表的键不会直接对应相应的内存地址，需要对键进行运算（哈希函数，同一个键的哈希值永远不变）得到哈希值，然后对哈希值进行二次处理（索引映射函数），得到内存地址。</p><ol><li><p>初始化哈希表（创建桶数组）</p><p>数组的每个位置称为“桶（Bucket）”，每个桶初始是空列表（存碰撞的键值对）</p></li><li><p>添加键值对</p><ol><li>计算哈希值：调用哈希函数hash();</li><li>映射数组索引：取模运算得到数组索引；</li><li>将键值对存入桶中。</li></ol></li><li><p>查找值</p><ol><li>计算索引（hash-&gt;取模）</li><li>遍历桶内数据</li><li>返回匹配值</li></ol></li><li><p>动态扩容</p><p>当桶数组的使用率（桶数/总桶数）超过阈值，会把数组长度翻倍，重新计算所有键的索引并迁移数据</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleHashTable</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size=<span class="number">8</span></span>):</span><br><span class="line">    <span class="variable language_">self</span>.size = size</span><br><span class="line">    <span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size)] <span class="comment"># 桶数组</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">_get_index</span>(<span class="params">self, key</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算键对应的数组索引（哈希函数+取模）&quot;&quot;&quot;</span></span><br><span class="line">    hash_value = <span class="built_in">hash</span>(key)</span><br><span class="line">    index = hash_value % <span class="variable language_">self</span>.size</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;添加/更新键值对&quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="variable language_">self</span>._get_index(key)</span><br><span class="line">    bucket = <span class="variable language_">self</span>.buckets[index] <span class="comment"># 定位到桶</span></span><br><span class="line">    <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(bucket):</span><br><span class="line">      <span class="keyword">if</span> k == key:</span><br><span class="line">        bucket[i] = (key, value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    bucket.append((key, value))</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">    index = <span class="variable language_">self</span>._get_index(key)</span><br><span class="line">    bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> bucket:</span><br><span class="line">      <span class="keyword">if</span> k == key:</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">f&quot;Key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; not found&quot;</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义魔法方法，self指向当前实例。</span></span><br><span class="line"><span class="string">    打印哈希表的桶数组状态，方便查看&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;HashTable(buckets=<span class="subst">&#123;self.buckets&#125;</span>)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>散列函数（哈希函数）是一种<strong>单向映射函数</strong>，核心作用是把任意长度、任意类型的输入（如字符串、数字、元组等 “键”），转换为固定长度的输出（通常是整数，即哈希值），且满足核心特性：</p><ol><li><strong>确定性</strong>：同一输入始终返回相同哈希值（比如多次计算<code>hash(&quot;abc&quot;)</code>结果一致）；</li><li><strong>高效性</strong>：计算速度极快，无需遍历 / 复杂运算；</li><li><strong>单向性</strong>：无法从哈希值反推原始输入；</li><li><strong>低碰撞性</strong>：不同输入尽可能生成不同哈希值（虽无法完全避免 “哈希碰撞”，但概率极低）。</li></ol><h2 id="冲突碰撞"><a href="#冲突碰撞" class="headerlink" title="冲突碰撞"></a>冲突碰撞</h2><p>冲突：哈希值取模运算得到的值重复</p><p>解决：</p><ol><li><p>封闭寻址法</p><p>桶数组是一个链表，但可能出现集群现象</p></li><li><p>开放寻址法</p><p>线形探测法：直接找紧挨着的下一个坑</p><p>二次探测法：探测$ n^n $ 后的坑</p></li></ol><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法（散列算法）：一种单向不可逆的数学函数：</p><ul><li>输入：任意长度的数据（字符串、文件、数字，“明文”）</li><li>输出：固定长度的二进制/整数结果（“哈希值/散列值/摘要”）</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">通俗解释</th></tr></thead><tbody><tr><td style="text-align:center">1. 确定性</td><td style="text-align:center">同一输入，永远得到同一哈希值（比如<code>hash(&quot;朱元璋&quot;)</code>每次结果都一样）。</td></tr><tr><td style="text-align:center">2. 快速计算</td><td style="text-align:center">无论输入多大（比如 10GB 文件），能快速算出哈希值（毫秒 / 秒级）。</td></tr><tr><td style="text-align:center">3. 单向不可逆</td><td style="text-align:center">无法从哈希值反推出原始输入（比如无法从<code>123456</code>反推出<code>&quot;朱元璋&quot;</code>）。</td></tr><tr><td style="text-align:center">4. 抗碰撞性</td><td style="text-align:center">很难找到两个不同输入，得到相同哈希值（分为 “弱抗碰撞” 和 “强抗碰撞”）。</td></tr><tr><td style="text-align:center">5. 雪崩效应</td><td style="text-align:center">输入的微小变化（比如改一个字符），会导致哈希值的巨大变化（比如全量不同）。</td></tr></tbody></table></div><ul><li><strong>弱抗碰撞</strong>：给定一个输入和它的哈希值，很难找到另一个输入得到相同哈希值；</li><li><strong>强抗碰撞</strong>：很难找到任意两个不同输入，得到相同哈希值（加密级哈希算法的核心要求）。</li></ul><h3 id="SHA-256（Secure-Hash-Algorithm）"><a href="#SHA-256（Secure-Hash-Algorithm）" class="headerlink" title="SHA-256（Secure Hash Algorithm）"></a>SHA-256（Secure Hash Algorithm）</h3><p>加密型哈希算法（安全散列函数</p><ul><li><p>输入：任意长度的字节数据</p></li><li><p>输出固定为256位（32字节）的哈希值，以64位十六进制字符串表示（1个十六进制对应4位二进制）</p></li><li><p><strong>字节填充</strong>：SHA-256 要求输入数据的长度必须是 <strong>512 （$2^9$)位的整数倍</strong>，不足则填充（这是算法的硬性要求）；</p></li><li><strong>位运算</strong>：算法全程依赖位运算（与 <code>&amp;</code>、或 <code>|</code>、异或 <code>^</code>、循环移位 <code>&gt;&gt;&gt;</code> 等），保证计算高效且不可逆；</li><li><strong>初始哈希值</strong>：SHA-256 内置 8 个 32 位的初始常量（来自自然数 <code>e</code> 和质数 <code>√2</code> 的小数部分前 32 位），作为哈希计算的起点；</li><li><strong>消息调度</strong>：将 512 位的数据块扩展为 64 个 32 位的字，用于后续的压缩计算。</li></ul><p><a href="https://www.simplilearn.com/tutorials/cyber-security-tutorial/sha-256-algorithm">https://www.simplilearn.com/tutorials/cyber-security-tutorial/sha-256-algorithm</a></p><hr><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1SZ4y1z7wT?vd_source=59c9078be8272e804fcbbcf1da9a9f94">哈希究竟代表什么？哈希表和哈希函数的核心原理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论库——NetworkX</title>
      <link href="/posts/3986d89a/"/>
      <url>/posts/3986d89a/</url>
      
        <content type="html"><![CDATA[<h1 id="NetworkX"><a href="#NetworkX" class="headerlink" title="NetworkX"></a>NetworkX</h1><p>NetworkX 是一个 Python 包，用于创建、操作和研究复杂网络的结构、动态和功能。它提供以下功能：</p><ul><li>用于研究社会、生物和基础设施网络结构和动态的工具；</li><li>适用于多种应用的标准编程接口和图形实现；</li><li>为协作式、多学科项目提供快速开发环境；</li><li>支持通过第三方后端实现算法加速和其他功能；</li><li>一个与现有数值算法和用 C、C++ 和 FORTRAN 编写的代码的接口；</li><li>能够轻松处理大型非标准数据集。</li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><blockquote><p><a href="https://networkx.org/documentation/latest/tutorial.html">官网</a></p></blockquote><h2 id="有向图和无向图"><a href="#有向图和无向图" class="headerlink" title="有向图和无向图"></a>有向图和无向图</h2><div class="table-container"><table><thead><tr><th style="text-align:center">图类型</th><th style="text-align:center">英文全称</th><th style="text-align:center">核心特征</th></tr></thead><tbody><tr><td style="text-align:center"><code>Graph</code></td><td style="text-align:center">Undirected Graph</td><td style="text-align:center">边无方向，<code>(u, v)</code> 等价于 <code>(v, u)</code>，代表 “相互关系”（如朋友、同事、连接）；</td></tr><tr><td style="text-align:center"><code>DiGraph</code></td><td style="text-align:center">Directed Graph</td><td style="text-align:center">边有方向，<code>u→v</code> 不等价于 <code>v→u</code>，代表 “单向关系”（如父子、关注、依赖）；</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">对比维度</th><th style="text-align:center"><code>Graph</code>（无向图）</th><th style="text-align:center"><code>DiGraph</code>（有向图）</th></tr></thead><tbody><tr><td style="text-align:center">边的方向性</td><td style="text-align:center">无方向，边是 “双向通道”</td><td style="text-align:center">有方向，边是 “单向箭头”</td></tr><tr><td style="text-align:center">边的存储形式</td><td style="text-align:center">添加 <code>(u, v)</code> 后，<code>u</code> 和 <code>v</code> 互相出现在对方邻接表中</td><td style="text-align:center">添加 <code>u→v</code> 后，仅 <code>u</code> 的邻接表包含 <code>v</code>，<code>v</code> 不包含 <code>u</code>（除非手动加 <code>v→u</code>）</td></tr><tr><td style="text-align:center">度（Degree）</td><td style="text-align:center">只有 <code>degree</code>（总关联边数）</td><td style="text-align:center">分 <code>in_degree</code>（入度，指向自身的边数）和 <code>out_degree</code>（出度，自身指向的边数）</td></tr><tr><td style="text-align:center">边的唯一性</td><td style="text-align:center"><code>(u, v)</code> 和 <code>(v, u)</code> 视为同一条边，无法重复添加</td><td style="text-align:center"><code>u→v</code> 和 <code>v→u</code> 是两条独立边，可分别添加</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:center">无方向关系（朋友、合作、道路连接、网络拓扑）</td><td style="text-align:center">有方向关系（父子、关注、转账、因果、流程）</td></tr></tbody></table></div><p>无向图：<code>nx.Graph()</code>；</p><p>有向图：<code>nx.DiGraph()</code>。</p><h2 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h2><p>创建不包含节点和边的空图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line">G = nx.Graph() <span class="comment"># 无向图</span></span><br></pre></td></tr></table></figure><p>图<a href="https://networkx.org/documentation/latest/reference/classes/graph.html#networkx.Graph"><code>Graph</code></a>是由节点（顶点）以及已标识的节点对（称为边、链接等）组成的集合。在 NetworkX 中，节点可以是任何<a href="https://docs.python.org/3/glossary.html#term-hashable">可哈希</a>对象，例如文本字符串、图像、XML 对象、另一个图、自定义节点对象等。</p><blockquote><p><code>None</code>不能用作节点</p></blockquote><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G.add_node(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 从可迭代容器中添加</span></span><br><span class="line">G.add_nodes_from([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 二元组，(节点，节点属性)</span></span><br><span class="line">G.add_nodes_from([(<span class="number">4</span>, &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span>&#125;), (<span class="number">5</span>, &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;green&quot;</span>&#125;)])</span><br></pre></td></tr></table></figure><p>查看节点个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.number_of_nodes()</span><br></pre></td></tr></table></figure><h2 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G.add_edge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">e = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">G.add_edge(*e) <span class="comment"># 解包元组</span></span><br><span class="line"><span class="comment"># 边列表</span></span><br><span class="line">G.add_edges_from([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment"># 边元组可以是包含两个节点的二元组，也可以是包含两个节点和一个边属性字典的三元组</span></span><br><span class="line">G.add_edges_from([(<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">&#x27;weight&#x27;</span>: <span class="number">3.1415</span>&#125;)])</span><br></pre></td></tr></table></figure><p>查看边缘个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.number_of_edges()</span><br></pre></td></tr></table></figure><h2 id="图的基本属性"><a href="#图的基本属性" class="headerlink" title="图的基本属性"></a>图的基本属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G.nodes <span class="comment"># 节点</span></span><br><span class="line">G.edges <span class="comment"># 边</span></span><br><span class="line">G.adj <span class="comment"># 邻居（邻接关系）</span></span><br><span class="line">G.degree <span class="comment"># 节点的度</span></span><br></pre></td></tr></table></figure><p>提供了一个持续更新的只读视图，用于查看图的结构。</p><blockquote><p><strong>视图对象</strong>：NetworkX 中 <code>Graph.edges</code>、<code>Graph.adj</code> 等返回的是 “动态视图”，而非静态列表，会实时反映图的变化。</p></blockquote><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>可调用模式对于检查节点或边的属性（以及多重图的边键）非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.edges(data=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>删除节点及其关联的边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G.remove_node(<span class="number">2</span>) <span class="comment"># 若没有该节点会报错，raise NetworkXError(f&quot;The node &#123;n&#125; is not in the graph.&quot;)</span></span><br><span class="line">G.remove_nodes_from(<span class="string">&quot;spam&quot;</span>) <span class="comment"># 删除可迭代对象中的元素</span></span><br></pre></td></tr></table></figure><p>删除特定边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G.remove_edge(<span class="number">1</span>,<span class="number">3</span>) <span class="comment"># 删除节点1和节点3之间的边</span></span><br><span class="line"><span class="comment"># 没有边报错 raise NetworkXError(f&quot;The edge &#123;u&#125;-&#123;v&#125; is not in the graph&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="图构造器"><a href="#图构造器" class="headerlink" title="图构造器"></a>图构造器</h2><p>NetworkX 中 <code>nx.Graph()</code>、<code>nx.DiGraph()</code> 等图对象的创建，本质是调用<strong>类的构造函数（<code>__init__</code> 方法）</strong> 实现的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据源格式</th><th style="text-align:center">示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">空值（默认）</td><td style="text-align:center"><code>nx.Graph()</code></td><td style="text-align:center">创建空图，无节点 / 边</td></tr><tr><td style="text-align:center">有效边列表（推荐）</td><td style="text-align:center"><code>nx.Graph([(1,2), (2,3)])</code></td><td style="text-align:center">列表中每个元素是 “一条边”（长度 2/3 的元组）</td></tr><tr><td style="text-align:center">带属性的有效边列表</td><td style="text-align:center"><code>nx.Graph([(1,2,{&quot;color&quot;:&quot;yellow&quot;})])</code></td><td style="text-align:center">长度 3 的元组，第三个元素是边属性字典</td></tr><tr><td style="text-align:center">已有图对象</td><td style="text-align:center"><code>nx.Graph(G_exist)</code></td><td style="text-align:center">复制已有图的结构和属性</td></tr><tr><td style="text-align:center">邻接表格式（字典）</td><td style="text-align:center"><code>nx.Graph({1: [2,3], 2: [3]})</code></td><td style="text-align:center">键是节点，值是邻接节点列表</td></tr></tbody></table></div><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>图对象无需逐步构建——指定图结构的数据可以直接传递给各个图类的构造函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">G.add_edge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">H = nx.DiGraph(G)  <span class="comment"># create a DiGraph using the connections from G</span></span><br><span class="line">edgelist = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">H = nx.Graph(edgelist)  <span class="comment"># create a graph from an edge list</span></span><br><span class="line">adjacency_dict = &#123;<span class="number">0</span>: (<span class="number">1</span>, <span class="number">2</span>), <span class="number">1</span>: (<span class="number">0</span>, <span class="number">2</span>), <span class="number">2</span>: (<span class="number">0</span>, <span class="number">1</span>)&#125;</span><br><span class="line">H = nx.Graph(adjacency_dict)  <span class="comment"># create a Graph dict mapping nodes to nbrs</span></span><br></pre></td></tr></table></figure><h2 id="节点和边的类型要求"><a href="#节点和边的类型要求" class="headerlink" title="节点和边的类型要求"></a>节点和边的类型要求</h2><h3 id="节点的核心要求：必须是「可哈希对象」"><a href="#节点的核心要求：必须是「可哈希对象」" class="headerlink" title="节点的核心要求：必须是「可哈希对象」"></a>节点的核心要求：必须是「可哈希对象」</h3><p>NetworkX 中节点本质是作为<strong>字典的键</strong>（邻接表 <code>G.adj</code> 是字典，节点是键），而 Python 字典的键必须满足「可哈希」—— 简单说就是：</p><ul><li><strong>可哈希对象</strong>：整数、字符串、元组（元素均为可哈希）、自定义类实例（实现了 <code>__hash__</code> 和 <code>__eq__</code>）；</li><li><strong>不可哈希对象</strong>（绝对不能用）：列表、字典、集合（这些对象可变，哈希值会变，会导致图结构错乱）。</li></ul><h3 id="边的属性要求：无类型限制（可关联任意对象）"><a href="#边的属性要求：无类型限制（可关联任意对象）" class="headerlink" title="边的属性要求：无类型限制（可关联任意对象）"></a>边的属性要求：无类型限制（可关联任意对象）</h3><p>边的属性（比如 <code>add_edge(n1, n2, attr=x)</code> 中的 <code>x</code>）没有任何限制：</p><ul><li>可以是数字（如 <code>weight=3.14</code>）、字符串（如 <code>relation=&quot;父子&quot;</code>）；</li><li>也可以是复杂对象（如 XML 记录、自定义类实例、文件句柄、甚至另一个图）；</li><li>本质是边的属性字典（<code>G[u][v]</code>）的值可以是任意 Python 对象。</li></ul><h2 id="节点和边的访问"><a href="#节点和边的访问" class="headerlink" title="节点和边的访问"></a>节点和边的访问</h2><h3 id="访问节点的邻居"><a href="#访问节点的邻居" class="headerlink" title="访问节点的邻居"></a>访问节点的邻居</h3><p><code>G[节点]</code> 等价于 <code>G.adj[节点]</code>，返回该节点的<strong>邻居节点 - 边属性</strong>映射视图（<code>AtlasView</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化带边属性的无向图</span></span><br><span class="line">G = nx.Graph([(<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;yellow&quot;</span>&#125;)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问节点1的所有邻居（等价于 G.adj[1]）</span></span><br><span class="line">neighbors_of_1 = G[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;节点1的邻居视图：&quot;</span>, neighbors_of_1)</span><br><span class="line"><span class="comment"># 输出：AtlasView(&#123;2: &#123;&#x27;color&#x27;: &#x27;yellow&#x27;&#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看邻居节点列表（转换为列表）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;节点1的邻居节点：&quot;</span>, <span class="built_in">list</span>(G[<span class="number">1</span>].keys()))</span><br><span class="line"><span class="comment"># 输出：[2]</span></span><br></pre></td></tr></table></figure><h3 id="访问-修改边的属性"><a href="#访问-修改边的属性" class="headerlink" title="访问 / 修改边的属性"></a>访问 / 修改边的属性</h3><h4 id="方式-1：双层下标（G-u-v-）"><a href="#方式-1：双层下标（G-u-v-）" class="headerlink" title="方式 1：双层下标（G[u][v]）"></a>方式 1：双层下标（<code>G[u][v]</code>）</h4><p>通过 <code>G[起始节点][目标节点]</code> 直接访问边的属性字典，支持读取和修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取边(1,2)的属性</span></span><br><span class="line">edge_1_2_attr = G[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边(1,2)初始属性：&quot;</span>, edge_1_2_attr)  <span class="comment"># 输出：&#123;&#x27;color&#x27;: &#x27;yellow&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增边并设置属性</span></span><br><span class="line">G.add_edge(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">G[<span class="number">1</span>][<span class="number">3</span>][<span class="string">&#x27;color&#x27;</span>] = <span class="string">&quot;blue&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边(1,3)的属性：&quot;</span>, G[<span class="number">1</span>][<span class="number">3</span>])  <span class="comment"># 输出：&#123;&#x27;color&#x27;: &#x27;blue&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已有边的属性</span></span><br><span class="line">G[<span class="number">1</span>][<span class="number">2</span>][<span class="string">&#x27;color&#x27;</span>] = <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边(1,2)修改后属性：&quot;</span>, G[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment"># 输出：&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="方式-2：G-edges-u-v-（更精准）"><a href="#方式-2：G-edges-u-v-（更精准）" class="headerlink" title="方式 2：G.edges[u, v]（更精准）"></a>方式 2：<code>G.edges[u, v]</code>（更精准）</h4><p>直接通过 <code>edges</code> 视图 + 节点对访问边属性，语义更清晰，推荐用于明确访问某条边的场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取边(1,2)的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边(1,2)属性：&quot;</span>, G.edges[<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 输出：&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改边属性</span></span><br><span class="line">G.edges[<span class="number">1</span>, <span class="number">3</span>][<span class="string">&#x27;weight&#x27;</span>] = <span class="number">0.8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边(1,3)新增权重后：&quot;</span>, G.edges[<span class="number">1</span>, <span class="number">3</span>])  <span class="comment"># 输出：&#123;&#x27;color&#x27;: &#x27;blue&#x27;, &#x27;weight&#x27;: 0.8&#125;</span></span><br></pre></td></tr></table></figure><p>⚠️ 注意：只有边已存在时，才能用下标修改属性；若边不存在，直接下标访问会抛出 <code>KeyError</code>。</p><h3 id="批量遍历：邻居与边的迭代"><a href="#批量遍历：邻居与边的迭代" class="headerlink" title="批量遍历：邻居与边的迭代"></a>批量遍历：邻居与边的迭代</h3><p>当需要批量处理所有邻居或边时，可通过迭代器实现，不同迭代方式适配不同需求。</p><h4 id="遍历所有（节点-邻居）对"><a href="#遍历所有（节点-邻居）对" class="headerlink" title="遍历所有（节点 - 邻居）对"></a>遍历所有（节点 - 邻居）对</h4><p>通过 <code>G.adj.items()</code> 或 <code>G.adjacency()</code> 迭代所有节点的邻居，两者效果完全一致（<code>G.adjacency()</code> 是 <code>G.adj.items()</code> 的别名）。</p><p>示例：筛选权重小于 0.5 的边（无向图）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建带权重的图</span></span><br><span class="line">FG = nx.Graph()</span><br><span class="line">FG.add_weighted_edges_from([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.125</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.75</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1.2</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.375</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有节点的邻居（无向图会遍历每条边两次）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=== 遍历（节点-邻居）对 ===&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> node, neighbors <span class="keyword">in</span> FG.adj.items():</span><br><span class="line">    <span class="keyword">for</span> neighbor, edge_attr <span class="keyword">in</span> neighbors.items():</span><br><span class="line">        weight = edge_attr[<span class="string">&#x27;weight&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> weight &lt; <span class="number">0.5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;node&#125;</span>, <span class="subst">&#123;neighbor&#125;</span>, <span class="subst">&#123;weight:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (1, 2, 0.125)</span></span><br><span class="line"><span class="comment"># (2, 1, 0.125)</span></span><br><span class="line"><span class="comment"># (3, 4, 0.375)</span></span><br><span class="line"><span class="comment"># (4, 3, 0.375)</span></span><br></pre></td></tr></table></figure><h4 id="遍历所有边（避免重复）"><a href="#遍历所有边（避免重复）" class="headerlink" title="遍历所有边（避免重复）"></a>遍历所有边（避免重复）</h4><p>通过 <code>G.edges.data()</code> 迭代所有边，可指定提取某类属性，是无向图中遍历边的最优方式（仅遍历每条边一次）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 遍历所有边（仅一次）===&quot;</span>)</span><br><span class="line"><span class="comment"># 提取所有边的weight属性（指定属性名，无该属性则返回None）</span></span><br><span class="line"><span class="keyword">for</span> u, v, weight <span class="keyword">in</span> FG.edges.data(<span class="string">&#x27;weight&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> weight &lt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;u&#125;</span>, <span class="subst">&#123;v&#125;</span>, <span class="subst">&#123;weight:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (1, 2, 0.125)</span></span><br><span class="line"><span class="comment"># (3, 4, 0.375)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetworkX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word写作</title>
      <link href="/posts/5b175032/"/>
      <url>/posts/5b175032/</url>
      
        <content type="html"><![CDATA[<h1 id="word如何制作整齐的封面信息"><a href="#word如何制作整齐的封面信息" class="headerlink" title="word如何制作整齐的封面信息"></a><a href="https://v.douyin.com/g4bYO65UOuA/">word如何制作整齐的封面信息</a></h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python开发模式安装</title>
      <link href="/posts/830e646c/"/>
      <url>/posts/830e646c/</url>
      
        <content type="html"><![CDATA[<p><code>python setup.py develop</code> 是 Python 包的<strong>开发模式安装</strong>，核心作用是<strong>将当前项目以 “动态链接” 的方式安装到环境中，而非复制文件</strong>—— 这对需要修改源码的库（如 Dassl.pytorch）至关重要。</p><h1 id="开发模式安装的本质"><a href="#开发模式安装的本质" class="headerlink" title="开发模式安装的本质"></a>开发模式安装的本质</h1><p>当你在 Dassl.pytorch 根目录执行 <code>python setup.py develop</code> 时，会完成以下 3 个关键操作：</p><ol><li><strong>生成包信息文件</strong>：在项目根目录生成 <code>dassl.egg-info</code> 文件夹，包含包的名称、版本、依赖、入口等元数据。</li><li><strong>创建动态链接</strong>：在 conda 环境的 <code>site-packages</code> 目录（如 <code>~/miniforge3/envs/dassl/lib/python3.8/site-packages/</code>）中，创建一个 <strong><code>.egg-link</code> 符号链接文件</strong>，指向你本地的 Dassl.pytorch 源码目录。</li><li><strong>注册可执行脚本（可选）</strong>：如果项目有 <code>console_scripts</code> 配置（如 Dassl 的工具脚本），会在环境的 <code>bin</code> 目录生成可执行文件的链接。</li></ol><h1 id="为什么-Dassl-必须用-develop-模式？"><a href="#为什么-Dassl-必须用-develop-模式？" class="headerlink" title="为什么 Dassl 必须用 develop 模式？"></a>为什么 Dassl 必须用 <code>develop</code> 模式？</h1><p>对比普通安装（<code>python setup.py install</code> 或 <code>pip install .</code>），开发模式的核心优势是 <strong>“源码修改即时生效，无需重新安装”</strong>—— 这对需要二次开发或调试的库（如 Dassl.pytorch）是刚需。</p><h4 id="1-普通安装的问题（不适合-Dassl）"><a href="#1-普通安装的问题（不适合-Dassl）" class="headerlink" title="1. 普通安装的问题（不适合 Dassl）"></a>1. 普通安装的问题（不适合 Dassl）</h4><p>普通安装会将 Dassl 的源码<strong>复制一份</strong>到 conda 环境的 <code>site-packages</code> 目录中。如果你修改了本地的 Dassl 源码（比如改了 <code>dassl/layers/__init__.py</code>），修改不会同步到 <code>site-packages</code> 中的复制版本，必须重新执行 <code>pip install .</code> 才能生效 —— 反复安装会极大降低开发效率。</p><h4 id="2-开发模式的优势（完美适配-Dassl）"><a href="#2-开发模式的优势（完美适配-Dassl）" class="headerlink" title="2. 开发模式的优势（完美适配 Dassl）"></a>2. 开发模式的优势（完美适配 Dassl）</h4><p>开发模式通过<strong>符号链接</strong>指向本地源码，而非复制文件。当你修改本地的 Dassl 源码后，<strong>无需任何额外操作，下次导入 <code>dassl</code> 时，修改会立即生效</strong>。例如：</p><ul><li>你在本地修改了 <code>dassl/engine/trainer.py</code> 中的训练逻辑；</li><li>直接运行依赖 Dassl 的代码（如 Swin Transformer 的训练脚本），新的训练逻辑会被直接调用；</li><li>无需重新安装 Dassl，也无需重启环境。</li></ul><h1 id="与-pip-install-e-的关系（等价命令）"><a href="#与-pip-install-e-的关系（等价命令）" class="headerlink" title="与 pip install -e . 的关系（等价命令）"></a>与 <code>pip install -e .</code> 的关系（等价命令）</h1><p>你在教程中看到的备选命令 <code>pip install -e .</code>，和 <code>python setup.py develop</code> 是<strong>完全等价的</strong>—— 两者都是开发模式安装，只是实现方式不同：</p><ul><li><code>python setup.py develop</code>：通过 <code>setup.py</code> 脚本的内置命令实现，是较老的方式；</li><li><code>pip install -e .</code>：通过 <code>pip</code> 的 <code>editable</code> 模式实现，是较新的推荐方式，兼容性更好（比如在 M 芯片 Mac 上，<code>pip install -e .</code> 通常比 <code>python setup.py develop</code> 更少报错）。</li></ul><h1 id="python-setup-py-develop执行机制"><a href="#python-setup-py-develop执行机制" class="headerlink" title="python setup.py develop执行机制"></a><code>python setup.py develop</code>执行机制</h1><p><strong><code>setuptools/distutils</code> 框架会接管整个执行流程</strong>。</p><ol><li><code>python setup.py develop</code> <strong>必须调用这个 <code>setup.py</code> 文件</strong>—— 命令中的 <code>setup.py</code> 就是指定要执行的脚本路径（默认当前目录的 <code>setup.py</code>）；</li><li>这个脚本<strong>不需要主函数</strong>，因为 <code>setuptools</code> 框架的执行逻辑是：<strong>加载 <code>setup.py</code> 并执行其中的所有顶层代码 → 解析 <code>setup()</code> 函数的配置 → 根据命令行参数（如 <code>develop</code>）执行对应逻辑</strong>；</li><li><code>setup()</code> 函数是整个脚本的「核心入口」，而非传统的 <code>if __name__ == &quot;__main__&quot;</code>。</li></ol><p>步骤 1：Python 解释器加载并执行 <code>setup.py</code> 的「顶层代码」</p><p>当你在终端输入 <code>python setup.py develop</code> 时，Python 解释器会做第一件事：<strong>逐行执行 <code>setup.py</code> 中的所有「顶层代码」</strong>（即不在函数内部的代码），具体包括：</p><ul><li>执行 <code>import numpy as np</code>/<code>import os.path as osp</code>/<code>from setuptools import setup, find_packages</code> → 导入依赖模块；</li><li>执行 <code>def readme(): ...</code>/<code>def find_version(): ...</code> 等函数定义 → 把这些函数加载到内存（但不执行函数体）；</li><li>执行 <code>setup(...)</code> → 这是最关键的一步，<code>setup()</code> 函数会被调用，且 <code>setuptools</code> 会把命令行参数（<code>develop</code>）传递给它。</li></ul><p>步骤 2：<code>setuptools</code> 解析命令行参数（<code>develop</code>）</p><p><code>setup()</code> 函数本身不包含「开发模式安装」的逻辑，它的核心作用是<strong>把你定义的包配置（名称、版本、依赖等）传递给 <code>setuptools</code> 框架</strong>。</p><p>当 <code>setup()</code> 被调用时，<code>setuptools</code> 会：</p><ol><li>读取命令行参数（<code>develop</code>），识别出你要执行「开发模式安装」；</li><li>结合 <code>setup()</code> 中的配置（如 <code>packages=find_packages()</code>、<code>install_requires=get_requirements()</code>），触发 <code>setuptools</code> 内置的 <code>develop</code> 命令逻辑；</li><li>此时，你定义的 <code>find_version()</code>/<code>get_requirements()</code> 等辅助函数才会被<strong>按需调用</strong>（比如 <code>setup()</code> 中的 <code>version=find_version()</code> 会触发 <code>find_version()</code> 执行，<code>install_requires=get_requirements()</code> 会触发 <code>get_requirements()</code> 执行）。</li></ol><p>步骤 3：执行 <code>develop</code> 命令的具体操作（框架内置逻辑）</p><p><code>setuptools</code> 内置的 <code>develop</code> 命令会根据 <code>setup()</code> 的配置，执行我们之前讲过的「开发模式安装」操作：</p><ol><li>调用 <code>find_version()</code> 获取版本号，调用 <code>get_requirements()</code> 获取依赖列表；</li><li>调用 <code>find_packages()</code> 扫描项目中的 Python 包；</li><li>在项目根目录生成 <code>dassl.egg-info</code> 文件夹（包含包元数据）；</li><li>在 conda 环境的 <code>site-packages</code> 目录创建 <code>dassl.egg-link</code> 符号链接（指向本地源码）；</li><li>检查并安装 <code>install_requires</code> 中定义的依赖（如果未安装）；</li><li>完成后返回成功提示。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频谱混叠</title>
      <link href="/posts/df30c197/"/>
      <url>/posts/df30c197/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-“时域”？什么是-“频域”？"><a href="#1-什么是-“时域”？什么是-“频域”？" class="headerlink" title="1. 什么是 “时域”？什么是 “频域”？"></a>1. 什么是 “时域”？什么是 “频域”？</h3><p>时域和频域是<strong>描述同一个信号的两种视角</strong>—— 就像 “描述一首歌”，可以说 “它的旋律随时间怎么变化（时域）”，也可以说 “它包含哪些高低音（频域）”。</p><p>以  <strong>图像（二维信号）</strong> 为例：</p><ul><li><strong>时域</strong>：就是你直接看到的 “像素的亮度随位置的变化”—— 比如一张图里，从左到右像素是 “亮→亮→暗→暗”，这就是 “时域的信号变化”。</li><li>频域：是 “这个变化的‘快慢程度’”——<ul><li>变化<strong>慢</strong>的部分 = 低频：比如大片的蓝色天空，像素亮度几乎不变，属于 “低频信号”；</li><li>变化<strong>快</strong>的部分 = 高频：比如猫的轮廓边缘（从白色毛突然变黑色背景）、细条纹纹理，像素亮度突然跳变，属于 “高频信号”。</li></ul></li></ul><h3 id="2-时域和频域的核心对应关系"><a href="#2-时域和频域的核心对应关系" class="headerlink" title="2. 时域和频域的核心对应关系"></a>2. 时域和频域的核心对应关系</h3><p><strong>时域的 “变化快慢” ↔ 频域的 “频率高低”</strong>：</p><ul><li>时域里 “变化越慢” → 频域里 “频率越低”；</li><li>时域里 “变化越快” → 频域里 “频率越高”。</li></ul><p>举个声音的例子（一维信号）：</p><ul><li>时域：声波随时间的振动波形（比如 “哆来咪” 的波形起伏）；</li><li>频域：这个声音里包含的 “音调高低”—— 低音（比如鼓点）是低频，高音（比如钢琴的高音键）是高频。</li></ul><h3 id="3-为什么频域里-“高频细节会被叠到低频区域”？"><a href="#3-为什么频域里-“高频细节会被叠到低频区域”？" class="headerlink" title="3. 为什么频域里 “高频细节会被叠到低频区域”？"></a>3. 为什么频域里 “高频细节会被叠到低频区域”？</h3><p>这是<strong>频谱混叠</strong>的表现，根源是 “下采样的‘采样速度’跟不上信号的‘变化速度’”（违反了奈奎斯特采样定理）。</p><p>还是用 <strong> 图像的细条纹（高频信号）</strong> 举例：</p><ul><li>时域里：一张图有 “1 像素黑、1 像素白” 的细条纹（变化极快，高频）；</li><li>若用<strong>大步数下采样</strong>（比如一次跳 2 个像素采样）：采样时会 “跳过中间的像素”，原本的 “黑 - 白 - 黑 - 白” 细条纹，可能被采样成 “黑 - 黑” 或 “白 - 白”，看起来像 “粗条纹”（变化慢，低频）；</li><li>对应到频域：原本的 “高频细条纹”，被错误地 “折叠” 到了 “低频粗条纹” 的区域 —— 这就是 “高频细节被叠到低频区域”。</li></ul><p>简单总结：时域是 “信号长什么样”，频域是 “信号由哪些快慢的成分组成”；下采样太快时，频域里快变化的高频成分会被当成慢变化的低频成分，这就是混叠。</p>]]></content>
      
      
      <categories>
          
          <category> 数字信号处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单位超球面</title>
      <link href="/posts/2da7df34/"/>
      <url>/posts/2da7df34/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单位超球面？"><a href="#什么是单位超球面？" class="headerlink" title="什么是单位超球面？"></a>什么是单位超球面？</h1><p>它是“高维空间里的‘单位球面’”，可以从低维例子推广理解： </p><ul><li><p>2维空间：“单位圆”是所有到原点距离为1的点（满足  $x^2 + y^2 = 1$ ）； </p></li><li><p>3维空间：“单位球面”是所有到原点距离为1的点（满足 $x^2 + y^2 + z^2 = 1$ ）； </p></li><li><p>高维空间（比如d维，(d&gt;3)）：“超球面”是高维空间的球面结构，<strong>单位超球面</strong>就是所有到原点距离为1的点的集合，对应向量的L₂范数（模长）为1，公式是： $  |\boldsymbol{v}|_2 = \sqrt{v_1^2 + v_2^2 + \dots + v_d^2} = 1  $</p></li></ul><h1 id="CLIP为什么要让嵌入向量分布在单位超球面？"><a href="#CLIP为什么要让嵌入向量分布在单位超球面？" class="headerlink" title="CLIP为什么要让嵌入向量分布在单位超球面？"></a>CLIP为什么要让嵌入向量分布在单位超球面？</h1><p>CLIP的核心是计算“图像嵌入”和“文本嵌入”的匹配度，用的是<strong>余弦相似度</strong>，公式是：</p><script type="math/tex; mode=display">\text{余弦相似度} = \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{\|\boldsymbol{u}\|_2 \cdot \|\boldsymbol{v}\|_2}</script><p>当嵌入向量经过 $L₂$ 归一化（模长=1，即落在单位超球面）时，分母为 $1 \times 1 = 1$，此时<strong>向量的点积</strong> $ \boldsymbol{u} \cdot \boldsymbol{v} $ 就直接等于余弦相似度。 这一步的作用是：排除向量“长度”的干扰，只通过向量之间的“夹角”衡量语义匹配度——夹角越小，点积（相似度）越大，说明图像和文本的语义越一致。 </p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SLAM</title>
      <link href="/posts/6073489d/"/>
      <url>/posts/6073489d/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1byKAewEUm?vd_source=59c9078be8272e804fcbbcf1da9a9f94">01  SLAM简介与应用场景</a></p><p>《SLAM十四讲（视觉）》</p><p>VIO</p><hr><h1 id="SLAM简介"><a href="#SLAM简介" class="headerlink" title="SLAM简介"></a>SLAM简介</h1><p><a href="https://www.bilibili.com/video/BV1byKAewEUm?vd_source=59c9078be8272e804fcbbcf1da9a9f94">01  SLAM简介与应用场景</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FAST-LIO</title>
      <link href="/posts/c325d296/"/>
      <url>/posts/c325d296/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1eu4y1o7pQ?vd_source=59c9078be8272e804fcbbcf1da9a9f94">香港大学开源FAST-LIO简介，对比及学习方法</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FAST-LIVO2</title>
      <link href="/posts/a2ded50b/"/>
      <url>/posts/a2ded50b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1TTCxBoEz7?vd_source=59c9078be8272e804fcbbcf1da9a9f94"> FAST-LIVO2</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高光谱相机</title>
      <link href="/posts/d1ad4bd1/"/>
      <url>/posts/d1ad4bd1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.csgpc.org/detail/21288.html">什么是高光谱？</a></p><p><a href="https://www.specim.com/cn/hyperspectral-imaging-applications/">高光谱应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 相机成像 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相机</title>
      <link href="/posts/9fbcc97b/"/>
      <url>/posts/9fbcc97b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/410476294">特种相机（一）—— 多光谱相机（基础篇）</a></p><hr><h1 id="光谱波段"><a href="#光谱波段" class="headerlink" title="光谱波段"></a>光谱波段</h1><p>光学领域中基于<strong>电磁波波长范围</strong>划分的<strong>光谱波段</strong>，广泛应用于计算机视觉、遥感、机器人感知（包括 SLAM）等领域。</p><div class="table-container"><table><thead><tr><th style="text-align:center">波段名称</th><th style="text-align:center">波长范围</th><th style="text-align:center">能量范围</th><th style="text-align:center">核心特性</th><th style="text-align:center">典型应用</th></tr></thead><tbody><tr><td style="text-align:center">伽马射线（γ）</td><td style="text-align:center">&lt; 0.01 nm</td><td style="text-align:center">&gt; 124 keV</td><td style="text-align:center">能量极高，穿透能力极强，可电离物质</td><td style="text-align:center">核物理、天体物理、医疗放疗</td></tr><tr><td style="text-align:center">伦琴射线（X 射线）</td><td style="text-align:center">0.01 nm ~ 10 nm</td><td style="text-align:center">124 eV ~ 124 keV</td><td style="text-align:center">能量高，穿透能力强，可穿透人体和金属</td><td style="text-align:center">医学成像、工业无损检测、安检</td></tr><tr><td style="text-align:center">紫外线（UV）</td><td style="text-align:center">10 nm ~ 400 nm</td><td style="text-align:center">3.1 eV ~ 124 eV</td><td style="text-align:center">能量高于可见光，可使荧光物质发光，具有杀菌作用，易被臭氧层吸收</td><td style="text-align:center">紫外成像、杀菌消毒、光刻技术</td></tr><tr><td style="text-align:center"><strong>可见光（VIS）</strong></td><td style="text-align:center">400 nm ~ 700 nm</td><td style="text-align:center">1.77 eV ~ 3.1 eV</td><td style="text-align:center">人类肉眼可见，是传统视觉的核心波段，纹理信息丰富</td><td style="text-align:center">普通 RGB 相机、SLAM、机器视觉</td></tr><tr><td style="text-align:center">红外线（IR）</td><td style="text-align:center">700 nm ~ 1 mm</td><td style="text-align:center">1.24 meV ~ 1.77 eV</td><td style="text-align:center">肉眼不可见，具有热辐射特性，按波长可进一步细分为近、中、长、远红外</td><td style="text-align:center">红外成像、热成像、遥感、SLAM</td></tr><tr><td style="text-align:center">微波（Microwave）</td><td style="text-align:center">1 mm ~ 1 m</td><td style="text-align:center">1.24 μeV ~ 1.24 meV</td><td style="text-align:center">波长较长，穿透能力强，不易受天气影响</td><td style="text-align:center">雷达、卫星通信、微波炉</td></tr><tr><td style="text-align:center">无线电波（Radio）</td><td style="text-align:center">&gt; 1 m</td><td style="text-align:center">&lt; 1.24 μeV</td><td style="text-align:center">波长最长，传播距离远，绕射能力强</td><td style="text-align:center">广播、电视、移动通信、导航</td></tr></tbody></table></div><h2 id="红外"><a href="#红外" class="headerlink" title="红外"></a>红外</h2><div class="table-container"><table><thead><tr><th style="text-align:center">子波段名称</th><th style="text-align:center">波长范围</th><th style="text-align:center">英文缩写</th><th style="text-align:center">工程别名</th><th style="text-align:center">关键特性</th><th style="text-align:center">成像技术</th><th style="text-align:center">典型应用场景（SLAM 相关）</th></tr></thead><tbody><tr><td style="text-align:center">近红外（Near-Infrared）</td><td style="text-align:center">700 nm ~ 1100 nm</td><td style="text-align:center">NIR</td><td style="text-align:center">反射红外、NIR-I</td><td style="text-align:center">与可见光相邻，普通 CMOS 传感器可响应（需去红外截止滤镜），依赖环境反射光，纹理丰富</td><td style="text-align:center">近红外相机、改装 RGB 相机</td><td style="text-align:center">低光照 SLAM、雾霾场景 SLAM、RGB-NIR 融合 SLAM</td></tr><tr><td style="text-align:center">扩展近红外（Extended NIR）</td><td style="text-align:center">1100 nm ~ 1700 nm</td><td style="text-align:center">NIR-II</td><td style="text-align:center">短波近红外</td><td style="text-align:center">穿透能力强于 NIR-I，可穿透薄雾、玻璃，需要专用 InGaAs 传感器</td><td style="text-align:center">扩展近红外相机</td><td style="text-align:center">玻璃遮挡 SLAM、强雾霾 SLAM</td></tr><tr><td style="text-align:center">短波红外（Short-Wave IR）</td><td style="text-align:center">1700 nm ~ 2500 nm</td><td style="text-align:center">SWIR</td><td style="text-align:center">近红外 - II、SWIR</td><td style="text-align:center">穿透能力极强，可穿透厚雾、沙尘、玻璃，依赖反射光，能区分材料光谱特征</td><td style="text-align:center">InGaAs 传感器相机</td><td style="text-align:center">极端环境 SLAM、工业检测 SLAM</td></tr><tr><td style="text-align:center">中波红外（Mid-Wave IR）</td><td style="text-align:center">2.5 μm ~ 5 μm</td><td style="text-align:center">MWIR</td><td style="text-align:center">中红外、热红外 - I</td><td style="text-align:center">不依赖环境光，可检测物体自身的热辐射（温度 &gt; 300K），穿透能力强于 LWIR</td><td style="text-align:center">制冷型红外传感器</td><td style="text-align:center">夜间 SLAM、热成像 SLAM、火灾检测 SLAM</td></tr><tr><td style="text-align:center">长波红外（Long-Wave IR）</td><td style="text-align:center">5 μm ~ 15 μm</td><td style="text-align:center">LWIR</td><td style="text-align:center">远红外、热红外 - II</td><td style="text-align:center">检测物体自身热辐射（温度 &gt; 0K），成像分辨率高，成本低于 MWIR，易受大气水汽影响</td><td style="text-align:center">非制冷型红外传感器</td><td style="text-align:center">夜间 SLAM、安防 SLAM、自动驾驶热成像 SLAM</td></tr><tr><td style="text-align:center">远红外（Far-Infrared）</td><td style="text-align:center">15 μm ~ 1 mm</td><td style="text-align:center">FIR</td><td style="text-align:center">极远红外</td><td style="text-align:center">波长最长，热辐射能量低，成像分辨率低，易被大气吸收</td><td style="text-align:center">专用远红外传感器</td><td style="text-align:center">天体物理、工业加热检测</td></tr></tbody></table></div><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><div class="table-container"><table><thead><tr><th>缩写</th><th>全称</th><th>波长范围</th><th>关键特性</th></tr></thead><tbody><tr><td>VIS</td><td>Visible Light（可见光）</td><td>400 nm ~ 700 nm</td><td>人类肉眼可见的波段，依赖环境光照，成像色彩丰富、纹理细节清晰，但易受光照变化、雾霾、遮挡影响</td></tr><tr><td>VISNIR</td><td>Visible-Near Infrared（可见光 - 近红外）</td><td>400 nm ~ 1100 nm</td><td>覆盖 VIS 和 NIR 两个波段，结合了可见光的纹理优势和近红外的低光照适应性，是<strong>多光谱相机的常用组合</strong></td></tr><tr><td>NIR-SWIR</td><td>Near Infrared-Short-Wave Infrared（近红外 - 短波红外）</td><td>700 nm ~ 2500 nm</td><td>覆盖 NIR 和 SWIR 两个波段，均为不可见光，穿透能力强（可穿透薄雾、水汽、部分非金属材料），不受可见光干扰，但成像分辨率相对较低，需要专用传感器</td></tr></tbody></table></div><h1 id="相机成像物理技术"><a href="#相机成像物理技术" class="headerlink" title="相机成像物理技术"></a>相机成像物理技术</h1><p><strong>不同光谱波段的信息，本质上来自于：</strong><br> <strong>物体对不同波长光的反射 / 吸收 / 透射特性不同，相机通过“光谱选择机制”把这些差异分离并记录下来。</strong></p><script type="math/tex; mode=display">I(λ)=E(λ)⋅R(λ)⋅S(λ)</script><ul><li>$E(\lambda)$：光源在波长 $\lambda $ 处的能量</li><li>$R(\lambda)$：物体在 $\lambda $ 处的反射率（你真正想要的）</li><li>$S(\lambda)$：相机/传感器在 $\lambda$ 处的响应</li></ul><h2 id="RGB-成像"><a href="#RGB-成像" class="headerlink" title="RGB 成像"></a>RGB 成像</h2><p>完整流程：</p><ol><li><strong>宽谱白光</strong>（太阳 / LED）照射物体</li><li>物体对不同波长的光反射不同</li><li>反射光进入相机镜头</li><li><strong>相机内部的 RGB 滤光结构，把光谱分成 R / G / B</strong></li><li>传感器分别记录三个波段的强度</li></ol><p>RGB相机分离光谱：<br>Bayer滤光片阵列，每个物理像素只看到一个波段，通过插值重建：$Pixel(x,y)=(R,G,B)$</p><blockquote><ol><li><strong>拜耳滤色器阵列（CFA）</strong></li></ol><p>在传感器的每个物理像素上面，只盖了<strong>一个颜色的滤光片</strong>（要么 R、要么 G、要么 B）。比如：</p><ul><li>某个物理像素上盖了 “红色滤光片”，它就只能接收红光，所以这个像素的原始输出只有 “R 通道的值”，G、B 通道是没有数据的；</li><li>旁边的像素盖了 “绿色滤光片”，原始输出就只有 “G 通道的值”，R、B 是空的。</li></ul><p>所以传感器直接输出的 “原始数据”，是一张 “马赛克状” 的图：每个物理像素只有 1 个颜色值，另外 2 个颜色值是缺失的。而我们最终看到的 “每个像素有 R、G、B 三个通道” 的彩色图，是<strong>去马赛克算法把周围像素的同颜色值插值补全后得到的结果</strong>—— 相当于用周围的 R 值补上当前像素的 R 值（如果它本身是 G 的话），以此类推，把每个像素的 3 个通道都填完整。<br>即：</p><blockquote><p>物理像素 + 单个滤光片 → 每个像素只采 1 个通道（原始数据）；</p><p>去马赛克算法插值补全 → 每个像素拥有 3 个通道（最终彩色图像）。</p></blockquote><ol><li>滤光片排布</li></ol><p><strong>滤光片的排布是固定规律的</strong>—— 核心逻辑是 “人眼对绿色更敏感，所以 G 滤光片的占比更高（50%），R 和 B 各占 25%”。</p><p>最常用的是<strong>RGGB 排布（也是默认的拜耳模式）</strong>，具体规律是：</p><ul><li>奇数行（第 1、3、5… 行）：按 “R→G→R→G…” 交替排列；</li><li>偶数行（第 2、4、6… 行）：按 “G→B→G→B…” 交替排列。</li></ul><ol><li><strong>去马赛克算法</strong></li></ol><p><strong>用周围像素的同通道信息，插值补全当前像素的缺失通道</strong>。比如，某个像素只有 “红色（R）” 值，算法会参考它上下左右像素的 “绿色（G）”“蓝色（B）” 值，通过双线性插值、自适应插值等方式，算出这个像素的 G 和 B 值；最终把每个像素的 R、G、B 三个通道都补全，得到完整的彩色图像。</p></blockquote><h2 id="多光谱成像"><a href="#多光谱成像" class="headerlink" title="多光谱成像"></a>多光谱成像</h2><p>在 RGB 的基础上，把“3 个滤波器”变成 “N 个滤波器”</p><h3 id="滤光轮相机"><a href="#滤光轮相机" class="headerlink" title="滤光轮相机"></a>滤光轮相机</h3><p><img src="https://pic3.zhimg.com/v2-aef31755825d76bdbbd8539dbb3ef01e_1440w.jpg" alt=""></p><p>原理：</p><ul><li>在镜头前放一个<strong>滤光片</strong></li><li>每次只允许一个波段的光通过</li><li>轮流拍摄</li></ul><p>通过旋转安装在传感器或镜头前面的滤光轮中的滤光片来捕获多通道光谱图像。这种滤光轮通常可以支持多达 12 个波段。然后从多光谱图像估计每像素光谱反射率。基于滤光轮的相机的优点是每个波段的全空间分辨率，而且滤光片可以根据应用要求定制和更换。<br>该系统的缺点包括成像速度慢且耗时、图像配准复杂、几何失真不好校正等。此外，还存在系统中包含机械运动部件（电动轮）的问题，长时间使用会降低精度甚至损坏，因此需要定期维护或更换。</p><h3 id="像素化多光谱滤波器阵列（快照式，多光谱-Bayer）"><a href="#像素化多光谱滤波器阵列（快照式，多光谱-Bayer）" class="headerlink" title="像素化多光谱滤波器阵列（快照式，多光谱 Bayer）"></a>像素化多光谱滤波器阵列（快照式，多光谱 Bayer）</h3><p><img src="https://pica.zhimg.com/v2-713aeb2d53b19d9e8ecf5eb02657d734_1440w.jpg" alt=""></p><p>原理：</p><ul><li>像 RGB Bayer 一样</li><li>但每个像素对应 <strong>不同波段（如 8/16 个）</strong></li></ul><p>是传统拜耳滤色器阵列（CFA，RGB 三通道）的扩展版。</p><ul><li>传统 Bayer（CFA）：每个像素对应 RGB 其中一个通道，单次拍摄后通过插值（去马赛克）得到全彩图像；</li><li>这里的多光谱滤光器阵列（MSFA）：把 Bayer 的 “RGB 三通道” 扩展成多光谱通道（4~40 个，覆盖 VIS、VISNIR 等波段），同样是 <strong>单次拍摄（快照式）</strong> 获取多光谱数据，再通过去马赛克算法重建各波段图像，所以也被称为 “多光谱 Bayer 结构”。</li></ul><p>这种捕获方法也称为快照马赛克成像。快照马赛克传感器可以支持 VIS（可见光）、VISNIR 和 NIR-SWIR 波长中 4 到 40 个通道之间的任何通道。<br>该方案的缺点：第一，在批量制造中实现非常高的像素一致性一直具有挑战性。第二，波段可能具有相对较高的串扰，这会影响整体光谱灵敏度、像素噪声参数和光谱重建的准确性。第三， 由于滤波器阵列中每个光谱带的采样较为稀疏，频段越多，每个频段的空间精度就越低。此外，多光谱滤波器阵列的去马赛克算法一直是一个具有挑战性的问题。</p><h3 id="多传感器二向色棱镜相机（分光棱镜并行采集）"><a href="#多传感器二向色棱镜相机（分光棱镜并行采集）" class="headerlink" title="多传感器二向色棱镜相机（分光棱镜并行采集）"></a>多传感器二向色棱镜相机（分光棱镜并行采集）</h3><p><img src="https://pic2.zhimg.com/v2-7486d749a07d122296aca175e4f9d4fb_1440w.jpg" alt=""></p><p><strong>靠 “二向色棱镜的涂层” 把入射光按波长拆分，让不同波段的光分别落到独立的传感器上，实现多光谱的 “并行全分辨率采集”</strong>。</p><p>原理：</p><ol><li><p><strong>入射光进入棱镜系统</strong>：镜头（Optics）收集的混合光（包含 VIS、NIR 等多波段）先进入二向色棱镜块。</p></li><li><p><strong>二向色涂层分光</strong>：棱镜表面的 “硬二向色涂层” 是核心 —— 它本质是<strong>精准的干涉滤光片</strong>：</p><ul><li><p>对某一波长范围的光（比如 R 波段），涂层会 “反射” 它，让这束光转向对应的传感器；</p></li><li><p>对另一波长范围的光（比如 G、B 波段），涂层会 “透射” 它，让光继续穿过棱镜，直到下一层涂层再拆分到对应的传感器。</p></li></ul><blockquote><p>二向色涂层：</p><p><strong>它能对不同波长的光，选择性地做 “反射” 或 “透射” 两种操作</strong>，而不是像普通滤光片那样 “吸收不需要的光”。</p><p>本质是一种<strong>精准的干涉滤光结构</strong>—— 它会对某一波长范围的光（比如 VIS 波段的红光）做 “反射”，把这束光导向对应的传感器；同时对另一波长范围的光（比如 NIR 波段的光）做 “透射”，让这束光穿过涂层，继续进入棱镜的下一层，直到被下一层二向色涂层拆分到另一个传感器。</p><p>根据需要拆分的波段数量，涂多层二向色涂层。</p></blockquote></li><li><p><strong>多传感器并行采集</strong>：每一个传感器只接收 “被棱镜分到自己这里的特定波段光”，且每个传感器都是<strong>全像素采集该波段</strong>（比如 G 波段传感器的所有像素都只收 G 光）。</p></li></ol><p>优势：</p><ul><li>不需要去马赛克算法：每个传感器直接输出对应波段的完整图像（全空间分辨率）；</li><li>光能利用率高：二向色涂层是 “分而不浪费”，不像 MSFA 的滤光片会过滤掉大部分光；</li><li>帧率 / 分辨率表现好：面扫描下能做到 3.2MP+100fps 的多波段同步采集。</li></ul><h3 id="多线相机（基于线扫描传感器）"><a href="#多线相机（基于线扫描传感器）" class="headerlink" title="多线相机（基于线扫描传感器）"></a>多线相机（基于线扫描传感器）</h3><p><img src="https://pic1.zhimg.com/v2-a734692b288e7100363a9741e8c3d36e_1440w.jpg" alt=""></p><p>原理：</p><p>线扫描相机的本质是 “逐行采集图像”（比如工业检测中常用来扫连续物体），而多线相机是给它加了<strong>多条平行的像素线</strong>，且<strong>每条像素线都配了独特的光谱带通滤光片</strong>：</p><ul><li>每条线只允许对应波段的光通过（比如第一条线过 R 光、第二条过 G 光、第三条过 B 光）；</li><li>当相机扫描目标时，每条线会同步采集 “对应波段的一行数据”，最终把所有线的行数据拼接起来，就能得到多光谱图像。</li></ul><p>例如：</p><p>四线多线相机：</p><ol><li><p>四线传感器的 “同步采集一行场景的 4 个波段”</p><p>四线相机的传感器上，有<strong>4 条平行且紧密排列的像素线</strong>，每条线都配了专属的波段滤光片（比如线 1=B、线 2=G、线 3=R、线 4=NIR）。</p><p>当相机对准目标时，<strong>这 4 条线会同时接收 “场景中同一行位置” 的光</strong>：</p><ul><li>线 1（B 滤光片）→ 采集该场景行的 B 波段像素行数据；</li><li>线 2（G 滤光片）→ 采集同一场景行的 G 波段像素行数据；</li><li>线 3（R 滤光片）→ 采集同一场景行的 R 波段像素行数据；</li><li>线 4（NIR 滤光片）→ 采集同一场景行的 NIR 波段像素行数据。</li></ul></li><li><p>相对运动，累积多组 “四行数据”</p><p>因为四线传感器只有 4 条线，无法一次拍全整个场景，所以需要<strong>相机和目标之间做匀速相对运动</strong>（比如相机沿垂直于像素线的方向向前移动，或目标匀速经过相机）。</p><p>每移动一个 “行间距” 的距离，相机就会再次采集一组新的 “4 条像素行数据”（对应场景的下一行位置）。不断重复这个过程，就能累积到<strong>成百上千组四行数据</strong>。</p></li><li><p>分波段拼接，得到 4 张完整的单波段图像</p><p>累积足够的四行数据后，软件会按<strong>波段分类</strong>进行拼接：</p><ul><li>把所有采集到的 “B 波段像素行数据” 按顺序拼接 → 得到完整的 B 波段图像；</li><li>把所有 “G 波段像素行数据” 拼接 → G 波段图像；</li><li>同理，得到 R 波段和 NIR 波段的完整图像。</li></ul></li></ol><h3 id="用于多光谱成像（线扫描）的推扫式相机"><a href="#用于多光谱成像（线扫描）的推扫式相机" class="headerlink" title="用于多光谱成像（线扫描）的推扫式相机"></a>用于多光谱成像（线扫描）的推扫式相机</h3><p><img src="https://pic4.zhimg.com/v2-476c8c60be3321a362e7e440505ae9f3_r.jpg" alt=""></p><ol><li><p>组成</p><p>镜头、成像光谱仪和硅基图像传感器（在 VIS-NIR 的情况下）或 InGaAs 传感器（在 NIR-SWIR 的情况下）。成像光谱仪由光色散单元和聚焦光学器件组成，构成推扫式相机的关键部件。内成像光谱仪，光线通过输入狭缝、准直器，到达色散单元，然后聚焦到图像传感器上，提供单条线的 x-λ 坐标。</p></li><li><p>原理</p><p>采用 “x-λ 扫描”：同时覆盖水平分辨率和多个波长带，沿传输方向（y 轴）顺序扫描，逐行捕获完整的空间 + 光谱信息。可以逐行捕获完整的空间和光谱信息。</p></li></ol><h2 id="多光谱VS高光谱"><a href="#多光谱VS高光谱" class="headerlink" title="多光谱VS高光谱"></a>多光谱VS高光谱</h2><p><img src="https://pic3.zhimg.com/v2-65b8d1a76245a8d612f48b2f7db2fb5e_1440w.jpg" alt="高光谱成像提供一段准连续范围的光谱"></p><p><img src="https://pic1.zhimg.com/v2-8473de809d4e12cbdfdf0bde9f87b54c_1440w.jpg" alt="多光谱成像由彼此离散定位的光谱带组成"></p><div class="table-container"><table><thead><tr><th style="text-align:center">维度</th><th style="text-align:center">多光谱（Multispectral）</th><th style="text-align:center">高光谱（Hyperspectral）</th></tr></thead><tbody><tr><td style="text-align:center">波段数量</td><td style="text-align:center">通常是 <strong>几个到几十个</strong>（比如 5-30 个）</td><td style="text-align:center">通常是 <strong>几十到几百个</strong>（比如 100-224 个，甚至更多）</td></tr><tr><td style="text-align:center">波段宽度</td><td style="text-align:center">较宽，一般 <strong>10-100 纳米</strong>（比如可见光里的 “红、绿、蓝” 就是宽波段）</td><td style="text-align:center">极窄，一般 <strong>1-10 纳米</strong>（能细分到连续的光谱区间）</td></tr><tr><td style="text-align:center">数据维度</td><td style="text-align:center">生成 “二维空间 + 少数光谱波段” 的简单数据</td><td style="text-align:center">生成 “二维空间 + 连续光谱维度” 的 “数据立方体”</td></tr><tr><td style="text-align:center">成像原理</td><td style="text-align:center">常用<strong>带通滤光片</strong>（比如给不同线阵配不同滤光片），直接过滤出几个特定波段的光，采集对应数据</td><td style="text-align:center">常用<strong>成像光谱仪</strong>（分光元件），把光分成连续的窄波段，再由传感器逐波段采集，能覆盖更精细的光谱区间</td></tr></tbody></table></div><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 相机成像 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>边缘计算</title>
      <link href="/posts/7beec643/"/>
      <url>/posts/7beec643/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是边缘计算"><a href="#什么是边缘计算" class="headerlink" title="什么是边缘计算"></a>什么是边缘计算</h1><p>边缘计算是一种致力于使计算尽可能靠近数据源、以减少延迟和带宽使用的网络理念，是一种<strong>把数据处理、存储等任务放到 “靠近数据源的边缘节点”</strong>（而不是全集中在云端）的技术架构。简而言之，边缘计算意味着在云端运行更少的进程，将这些进程移动到本地，例如用户的计算机、<a href="https://www.cloudflare.com/learning/cloud/what-is-the-cloud/">IoT 设备</a>或<a href="https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/">边缘服务器</a>。将计算放到网络边缘可以最大程度地减少<a href="https://www.cloudflare.com/learning/serverless/glossary/client-side-vs-server-side/">客户端和服务器</a>之间必须进行的长距离通信量。</p><blockquote><p>网络边缘：<br>对于互联网设备，网络边缘是设备或包含设备的本地网络与互联网通信的位置。边缘是个比较模糊的术语。例如，可以将用户的计算机或 IoT 摄像头内部的处理器视为网络边缘，但也可以将用户的路由器、ISP 或本地边缘服务器视为边缘。重要的是，网络边缘在地理位置上靠近设备，与<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源站</a>和云服务器不同，后者可能与它们相互通信的设备相距很远。</p></blockquote><h1 id="边缘计算与其他计算模型"><a href="#边缘计算与其他计算模型" class="headerlink" title="边缘计算与其他计算模型"></a>边缘计算与其他计算模型</h1><p><strong>最早期的计算机</strong>是巨大笨重的机器，只能直接访问或通过终端访问，这些终端基本上是计算机的扩展。随着<strong>个人计算机</strong>的发明，计算可以用一种更加分散的方式进行。曾几何时，个人计算是占主导地位的计算模式。应用程序在本地运行，数据存储于用户的设备上，有时在本地数据中心内。</p><p><strong>云计算</strong>是更新的发展，与这种基于本地的计算相比，它提供了许多优势。云服务集中在供应商管理的“云”(或数据中心的集合)中，可以从互联网上的任何设备访问。</p><p>但是，由于用户与托管云服务的数据中心之间的距离，云计算可能会引入<a href="https://www.cloudflare.com/learning/performance/glossary/what-is-latency/">延迟</a>。<strong>边缘计算</strong>使计算更接近最终用户，以最小化数据必须传输的距离，同时仍然保留云计算的集中化性质。</p><p>总而言之：</p><ul><li>早期计算：集中式应用程序，仅在一台孤立的计算机上运行</li><li>个人计算：本地运行的去中心化应用程序</li><li>云计算：在数据中心运行的集中式应用程序</li><li>边缘计算：在靠近用户的地方——设备本身或者网络边缘——运行的集中式应用程序</li></ul><h1 id="边缘计算应用"><a href="#边缘计算应用" class="headerlink" title="边缘计算应用"></a>边缘计算应用</h1><h2 id="安全系统监控"><a href="#安全系统监控" class="headerlink" title="安全系统监控"></a>安全系统监控</h2><p><strong>让摄像头本地运行运动检测程序</strong>，只把“有活动的视频片段”传到云服务器，而不是全量传原始视频。</p><p> 解决的问题：既省了大量带宽（不用传没动静的冗余视频），又减轻了云服务器的处理/存储负载，还能更快响应异常情况。  </p><h2 id="IoT设备"><a href="#IoT设备" class="headerlink" title="IoT设备"></a>IoT设备</h2><p>比如智能音箱、智能门锁这类设备：<strong>把简单的指令处理代码放到设备本地运行</strong>，不用每次都把数据传到云端再等结果。 </p><p>举个例子：智能音箱收到“调低音量”的指令，本地直接执行操作，不用等云端解析反馈；智能门锁本地识别指纹/密码，不用连网才能开门。 </p><p>解决的问题：交互延迟大幅降低，设备响应更流畅，甚至断网时基础功能也能正常用。  </p><h2 id="自动驾驶汽车"><a href="#自动驾驶汽车" class="headerlink" title="自动驾驶汽车"></a>自动驾驶汽车</h2><p>自动驾驶依赖摄像头、雷达等传感器的实时数据：<strong>把决策代码放到汽车自带的车载计算单元（边缘节点）本地运行</strong>，不用等数据传到云端处理再发指令。</p><p> 比如遇到突然窜出的行人，车载计算单元能毫秒级完成“识别→判断→刹车”的流程；要是等云端指令，延迟早就让事故发生了。 </p><p>解决的问题：满足自动驾驶的“实时响应”刚需，保障行驶安全。  </p><h2 id="更高效的缓存（结合CDN）"><a href="#更高效的缓存（结合CDN）" class="headerlink" title="更高效的缓存（结合CDN）"></a>更高效的缓存（结合CDN）</h2><p> CDN是分布在各地的“边缘服务器”（本来是存图片、视频的），边缘计算让它不仅能存内容，还能<strong>本地运行代码自定义缓存逻辑</strong>。</p><p>比如视频网站，会根据你所在的区域、常看的内容，让你附近的CDN边缘服务器提前缓存你可能要看的片段；你打开视频时，直接从近的边缘服务器拿内容，不用从遥远的云服务器拉取。 </p><p>解决的问题：内容加载速度更快，也省了跨区域传输的带宽。  </p><h2 id="医疗监控设备"><a href="#医疗监控设备" class="headerlink" title="医疗监控设备"></a>医疗监控设备</h2><p>比如重症病人的心率监护仪、呼吸机：<strong>把“异常数据检测”的代码放到设备本地运行</strong>，不用等数据传到云端再判断报警。</p><p>比如心率突然超标时，设备本地直接触发报警，同时再把数据同步到云；要是等云端反馈，可能耽误抢救时机。 </p><p>解决的问题：满足医疗场景的“实时响应”刚需，避免关键信息延迟。  </p><h2 id="视频会议"><a href="#视频会议" class="headerlink" title="视频会议"></a>视频会议</h2><p>多人视频会议的视频流很占带宽：<strong>把“视频压缩、流转发”的进程放到离参会者近的边缘节点运行</strong>，而不是全传到云端集中处理。 </p><p>比如你在北京开会，视频流先传到北京的边缘节点压缩、转发，不用传到千里之外的云服务器再分发。 </p><p>解决的问题：减少数据传输的距离和带宽消耗，会议延迟更低、更流畅。 </p><h1 id="边缘计算优势"><a href="#边缘计算优势" class="headerlink" title="边缘计算优势"></a>边缘计算优势</h1><ul><li>减少延迟</li><li>减少带宽使用和相关成本</li><li>减少服务器资源消耗和相关成本</li><li>增加功能</li></ul><h2 id="节省成本"><a href="#节省成本" class="headerlink" title="节省成本"></a>节省成本</h2><p>边缘计算有助于最大程度地减少带宽使用量和服务器资源消耗。带宽和云资源是有限的，并且需要花费成本。Statista <a href="https://www.statista.com/statistics/471264/iot-number-of-connected-devices-worldwide/">预测</a>，随着每个家庭和办公室都配备智能相机、打印机、温度调节装置甚至烤面包机，到 2025 年，全球将安装超过 750 亿个 IoT 设备。为了支持所有这些设备，必须将大量计算移到边缘。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>将流程移至边缘的另一个重要优势是减少延迟。设备每次需要与某处的远程服务器通信时，都会造成延迟。例如，同一办公室中的两个同事在 IM 平台上聊天可能会遇到相当大的延迟，因为设备必须将每条消息路由到建筑物外，与全球某处的服务器通信，然后再传回，最后才能出现在收信人的屏幕上。如果将该过程放到边缘，并且由公司的内部路由器负责传输办公室内的聊天记录，则不会出现明显的延迟。</p><p>同样，当各种 Web 应用的用户遇到必须与外部服务器进行通信的进程时，他们将感受到延迟。这些延迟的持续时间将根据可用带宽和服务器的位置而变化，但是可以通过将更多进程引入网络边缘来完全避免这些延迟。</p><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><p>此外，边缘计算可以提供以前无法提供的新功能。例如，公司可以使用边缘计算在边缘处理和分析数据，使得实时处理成为可能。</p><p>完全减轻额外硬件需求的一种方法是利用边缘服务器。例如，借助 Cloudflare 分散在全球各地的 330 个边缘服务器组成的网络，Cloudflare 的客户可以使用 <a href="https://www.cloudflare.com/products/cloudflare-workers/">Cloudflare Workers</a> 在全球范围内运行边缘代码。</p><h1 id="边缘计算缺点"><a href="#边缘计算缺点" class="headerlink" title="边缘计算缺点"></a>边缘计算缺点</h1><p>边缘计算的一个缺点是会增加<a href="https://www.cloudflare.com/learning/security/glossary/attack-vector/">攻击媒介</a>。随着更多“智能”设备的加入，例如具有强大内置计算机的边缘服务器和 IoT 设备，给恶意攻击者带来入侵这些设备的新机会。</p><p>边缘计算的另一个缺点是它需要更多的本地硬件。例如，虽然 IoT 摄像头需要内置计算机才能将原始视频数据发送到 Web 服务器，但如果要运行自己的运动检测算法，就需要一台功能更强大、有更大处理能力的复杂计算机。但是，硬件成本的下降使得构建更智能设备的成本变得更为低廉。</p><hr><blockquote><p><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/what-is-edge-computing/">https://www.cloudflare.com/zh-cn/learning/serverless/glossary/what-is-edge-computing/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪代码</title>
      <link href="/posts/ce589481/"/>
      <url>/posts/ce589481/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言(C, Java, Pascal)实现。因此，伪代码必须结构清晰，代码简单，可读性好，并且类似自然语言。</p><p><strong>伪代码的优点</strong></p><ul><li><p>提高任何方法的可读性。这是开始实现算法的最佳方法之一。</p></li><li><p>充当程序与算法或流程图之间的桥梁。也可以作为一个粗略的文档，因此当写出伪代码时，可以很容易地理解一个开发人员的程序。在行业中，文档是必不可少的。这就是证明伪代码至关重要的地方。</p></li><li><p>伪代码的主要目标是解释程序的每一行应该做什么，从而使程序员更容易构建代码构建阶段。</p></li></ul><h1 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h1><ul><li>在伪代码中，<strong>每一条指令占一行</strong>(else if 例外)，指令后不跟任何符号；</li><li><strong>“缩进”</strong> 表示程序中的分支程序结构（同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进）；</li><li>通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上行号，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤；</li><li>每一行可以加上编号（也可不加）。</li></ul><h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>算法中出现的数组、变量可以是：整数、实数、字符、字符串、指针。在注释中给出定义。</p><h2 id="指令的表示"><a href="#指令的表示" class="headerlink" title="指令的表示"></a>指令的表示</h2><p>在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。</p><p>逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not）。</p><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>赋值语句是如下形式的语句：<code>a←b</code>。<br>这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。</p><p>变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。</p><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>goto语句具有形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label（<span class="keyword">goto</span>标号）</span><br></pre></td></tr></table></figure><p>它将导致转向具有指定标号的语句。</p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>条件语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i=<span class="number">10</span></span><br><span class="line">    then xxxx</span><br><span class="line">    <span class="keyword">else</span> xxxx <span class="comment">//else 和 then 要对齐</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">if</span> i=<span class="number">10</span></span><br><span class="line">    then xxxx <span class="comment">//if 后面必定跟上then，else后面不用跟then</span></span><br><span class="line">    elseif i=<span class="number">9</span> <span class="comment">//elseif 要连在一起写</span></span><br><span class="line">        then xxxx</span><br><span class="line">        yyyy</span><br><span class="line">    <span class="keyword">else</span>  xxxx <span class="comment">//else 跟在 elseif 的 then 对齐</span></span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>while语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> time&lt;<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span>  xxxxx <span class="comment">//while后面必定要紧跟缩进的do</span></span><br><span class="line">    xxxxx</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>for语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var &lt;- init to limit by incr </span><br><span class="line"><span class="keyword">do</span> s</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里var是循环变量（Loop Variable），init（初始值（Initial Value））、limit（终止条件值（Limit / Bound））和incr（增量（Increment / Step））都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若<code>incr≥0</code>，则只要<code>var≤limit</code>，就执行s并且将incr加到var上。（假若<code>incr&lt;0</code>，则只要<code>var≥limit</code>，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。</p><h2 id="程序的结束"><a href="#程序的结束" class="headerlink" title="程序的结束"></a>程序的结束</h2><p>exit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。</p><p>return用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>算法中的注释被括在 /<em> </em>/ 之中。</p><h2 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h2><p>函数的伪代码格式例子为：search（A，name）， 参数类型可以不给出，但必须在注释中说明。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>问题描述</strong><br> 给定一组学生成绩，完成以下任务：</p><ol><li>计算平均分</li><li>查找最高分</li><li>判断是否存在不及格成绩</li><li>支持按学号查询成绩</li><li>若数据非法则提前终止程序</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Algorithm StudentScoreProcess(A, n, query_id)</span><br><span class="line">/*</span><br><span class="line">A：整数数组，存储学生成绩</span><br><span class="line">n：整数，学生人数</span><br><span class="line">query_id：整数，待查询的学生编号（从1开始）</span><br><span class="line">输出：平均分、最高分、不及格提示、查询结果</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">if n &lt;= 0</span><br><span class="line">then return &quot;Error: invalid student number&quot;</span><br><span class="line"></span><br><span class="line">sum &lt;- 0</span><br><span class="line">max_score &lt;- A[1]</span><br><span class="line">has_fail &lt;- false</span><br><span class="line"></span><br><span class="line">for i &lt;- 1 to n by 1</span><br><span class="line">do</span><br><span class="line">sum &lt;- sun + A[i]</span><br><span class="line"></span><br><span class="line">if A[i] &lt; 60</span><br><span class="line">then has_fail &lt;- true</span><br><span class="line">if A[i] &gt; max_score</span><br><span class="line">then max_score &lt;- A[i]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">avg &lt;- sum / n</span><br><span class="line">if has_fail = true</span><br><span class="line">then print &quot;There exists failing score.&quot;</span><br><span class="line">else</span><br><span class="line">print &quot;All student passed.&quot;</span><br><span class="line"></span><br><span class="line">print &quot;Average score = &quot;, avg</span><br><span class="line">print &quot;Maximum score = &quot;, max_score</span><br><span class="line"></span><br><span class="line">goto QUERY</span><br><span class="line"></span><br><span class="line">/*查询模块*/</span><br><span class="line">QUERY:</span><br><span class="line">if query_id &lt; 1 or query_id &gt; n</span><br><span class="line">then return &quot;Query ID out of range&quot;</span><br><span class="line">else</span><br><span class="line">print &quot;Score of student&quot;, query_id, &quot;is &quot;, A[query_id]</span><br><span class="line"></span><br><span class="line">Function SearchScore(A, n, target)</span><br><span class="line">/*</span><br><span class="line">   A：整数数组</span><br><span class="line">   n：数组长度</span><br><span class="line">   target：待查找的成绩</span><br><span class="line">   返回：找到则返回索引，否则返回 -1</span><br><span class="line">*/</span><br><span class="line">i ← 1</span><br><span class="line">while i ≤ n</span><br><span class="line">    do</span><br><span class="line">       if A[i] = target</span><br><span class="line">           then return i</span><br><span class="line">       i ← i + 1</span><br><span class="line">   end</span><br><span class="line">return -1</span><br><span class="line"></span><br><span class="line">return &quot;Process finished&quot;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考<br><a href="https://www.cnblogs.com/linuxAndMcu/p/11242905.html">https://www.cnblogs.com/linuxAndMcu/p/11242905.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/posts/7c10b52f/"/>
      <url>/posts/7c10b52f/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>KNN（K-Nearest Neighbors，K 近邻算法）是一种 <strong>基于实例（Instance-based）</strong> 的监督学习方法，其核心思想可以概括为：<br><strong>“一个样本的类别由与它最相似的 K 个样本共同决定。”</strong></p><h2 id="物以类聚"><a href="#物以类聚" class="headerlink" title="物以类聚"></a>物以类聚</h2><p>KNN 的思想来源于人类日常生活中的直觉判断，即 <strong>“物以类聚”</strong>。</p><p>例如，在一个学生成绩数据集中：</p><ul><li>如果某个新学生的成绩与多数“优秀”学生非常接近，</li><li>那么我们有理由认为该学生也属于“优秀”类别。</li></ul><p>在 KNN 中，这种“接近”通过<strong>距离度量</strong>来进行量化。</p><h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><p>隐含了一个重要假设：<br><strong>在特征空间中，距离相近的样本具有相似的属性或类别。</strong></p><p>即：</p><ul><li>特征空间中的 <strong>局部结构</strong> 比全局模型更重要；</li><li>不同类别间在空间上应当具有一定的可分性。</li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><script type="math/tex; mode=display">\mathcal{D} = \{(x_1, y_1), (x_2, y_2), \dots, (x_n, y_n)\}</script><ul><li>$x_i \in \mathbb{R}^d$ 表示第 $i$ 个样本的特征向量；</li><li>$y_i$ 表示对应的类别标签或数值输出。</li></ul><p>对于一个待分类（或回归）的新样本 $x$，KNN 的基本步骤如下：</p><ol><li>计算样本 $x$ 与训练集中所有样本之间的距离；</li><li>按距离从小到大排序，选取距离最近的 $K$ 个样本；</li><li>根据这 $K$ 个邻居的标签对 $x$ 进行预测。</li></ol><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>KNN 算法是一种<strong>懒惰学习（Lazy Learning）</strong>方法，其训练阶段几乎不进行任何计算，主要计算集中在预测阶段。</p><p>对于一个待预测样本 $x$，KNN 的基本流程如下：</p><ol><li>计算 $x$ 与训练集中所有样本之间的距离；</li><li>按距离从小到大对样本进行排序；</li><li>选取距离最近的 $K$ 个样本作为近邻；</li><li>根据任务类型（分类或回归）输出预测结果。</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><hr><p><strong>Algorithm 1</strong>: K-Nearest Neighbors (KNN)</p><hr><p><strong>Input</strong>:  </p><ul><li>Training dataset $\mathcal{D} = {(x_1, y_1), \dots, (x_n, y_n)}$  </li><li>Query sample $x$  </li><li>Number of neighbors $K$  </li><li>Distance metric $d(\cdot, \cdot)$  </li></ul><p><strong>Output</strong>:  </p><ul><li>Predicted label $\hat{y}$</li></ul><hr><p>1:  Initialize distance list $D = \emptyset$;<br>2:  <strong>for</strong> $i = 1$ <strong>to</strong> $n$ <strong>do</strong><br>3:  Compute distance $d_i = d(x, x_i)$;<br>4:  Append $(d_i, y_i)$ to $D$;<br>5:  <strong>end for</strong>  </p><p>6:  Sort $D$ in ascending order according to $d_i$;<br>7:  Select the first $K$ elements from $D$ as $\mathcal{N}_K(x)$;  </p><p>8:  <strong>if</strong> task is classification <strong>then</strong><br>9:  $\hat{y} \leftarrow$ majority vote of labels in $ \mathcal{N}_K(x) $ ;</p><p>10: <strong>else if</strong> task is regression <strong>then</strong>  </p><p>11:  $ \hat{y} \leftarrow \frac{1}{K} \sum_{(d_i, y_i) \in \mathcal{N}_K(x)} y_i $ ;</p><p>12: <strong>end if</strong>  </p><p>13: <strong>return</strong> $\hat{y}$;</p><hr><h2 id="距离度量方法"><a href="#距离度量方法" class="headerlink" title="距离度量方法"></a>距离度量方法</h2><p>在 KNN 算法中，“相似度”的判断完全依赖于<strong>距离度量函数</strong>。<br>不同的距离度量方式会直接影响邻居的选取，从而影响最终分类或回归结果。</p><p>设两个样本点为<br>$x = (x_1, x_2, \dots, x_d)$，<br>$y = (y_1, y_2, \dots, y_d)$，<br>其中 $d$ 表示特征维度。</p><h3 id="欧式距离（Euclidean-Distance）"><a href="#欧式距离（Euclidean-Distance）" class="headerlink" title="欧式距离（Euclidean Distance）"></a>欧式距离（Euclidean Distance）</h3><p>欧氏距离是最常用、最直观的一种距离度量方式，表示两点在欧几里得空间中的直线距离。</p><script type="math/tex; mode=display">d(x, y) = \sqrt{\sum_{i=1}^{d} (x_i - y_i)^2}</script><p><strong>特点：</strong></p><ul><li>适用于连续数值型特征；</li><li>对特征尺度敏感，常需进行归一化或标准化；</li><li>在低维空间中效果较好。</li></ul><h3 id="曼哈顿距离（Manhattan-Distance）"><a href="#曼哈顿距离（Manhattan-Distance）" class="headerlink" title="曼哈顿距离（Manhattan Distance）"></a>曼哈顿距离（Manhattan Distance）</h3><p>曼哈顿距离又称为 $L_1$ 距离，表示在坐标轴方向上的距离总和。</p><script type="math/tex; mode=display">d(x, y) = \sum_{i=1}^{d} |x_i - y_i|</script><p><strong>特点：</strong></p><ul><li>对异常值相对不如欧氏距离敏感；</li><li>适用于高维或稀疏特征空间；</li><li>在某些实际应用中比欧氏距离更稳定。</li></ul><h3 id="闵可夫斯基距离（Minkowski-Distance）"><a href="#闵可夫斯基距离（Minkowski-Distance）" class="headerlink" title="闵可夫斯基距离（Minkowski Distance）"></a>闵可夫斯基距离（Minkowski Distance）</h3><p>闵可夫斯基距离是欧氏距离和曼哈顿距离的统一形式，其定义如下：</p><script type="math/tex; mode=display">d(x, y) = \left( \sum_{i=1}^{d} |x_i - y_i|^p \right)^{\frac{1}{p}}, \quad p \geq 1</script><p>当：</p><ul><li>$p = 1$ 时，为曼哈顿距离；</li><li>$p = 2$ 时，为欧氏距离；</li><li>$p \to \infty$ 时，为切比雪夫距离。</li></ul><p><strong>特点：</strong></p><ul><li>提供了一种灵活的距离度量框架；</li><li>可根据具体问题选择合适的 $p$ 值。</li></ul><h3 id="余弦相似度（Cosine-Similarity）"><a href="#余弦相似度（Cosine-Similarity）" class="headerlink" title="余弦相似度（Cosine Similarity）"></a>余弦相似度（Cosine Similarity）</h3><p>余弦相似度衡量的是两个向量在方向上的相似性，而非距离大小，常用于文本、推荐系统等领域。</p><script type="math/tex; mode=display">\text{cos}(x, y) = \frac{x \cdot y}{\|x\| \|y\|}</script><p>其中，$x \cdot y$ 表示向量点积，$|x|$ 表示向量的 $L_2$ 范数。</p><p><strong>特点：</strong></p><ul><li>与向量的模长无关；</li><li>更关注特征的方向信息；</li><li>适合高维稀疏数据。</li></ul><h2 id="参数影响"><a href="#参数影响" class="headerlink" title="参数影响"></a>参数影响</h2><p>KNN 算法的性能对参数设置高度敏感，主要包括 <strong>K 值的选择</strong> 和 <strong>距离度量方式</strong>。</p><h3 id="K值"><a href="#K值" class="headerlink" title="K值"></a>K值</h3><p>$K$ 是 KNN 中最关键的超参数，其取值直接影响模型的偏差与方差。</p><ul><li><p><strong>K 较小（如 $K=1$）</strong>：</p><ul><li>模型对噪声敏感；</li><li>决策边界复杂；</li><li>容易发生过拟合（High Variance）。</li></ul></li><li><p><strong>K 较大</strong>：</p><ul><li>决策边界更平滑；</li><li>可能忽略局部结构；</li><li>容易发生欠拟合（High Bias）。</li></ul></li></ul><p>通常需要通过交叉验证等方法选择合适的 $K$ 值。</p><h3 id="距离度量方式的影响"><a href="#距离度量方式的影响" class="headerlink" title="距离度量方式的影响"></a>距离度量方式的影响</h3><p>不同的距离度量会导致不同的“近邻”集合：</p><ul><li>欧氏距离对特征尺度敏感，需进行特征归一化；</li><li>曼哈顿距离在高维空间中更具鲁棒性；</li><li>余弦相似度更关注方向相似性而非数值大小。</li></ul><p>因此，在实际应用中应根据数据分布和任务特点选择合适的距离度量方式。</p><h3 id="特征尺度的影响"><a href="#特征尺度的影响" class="headerlink" title="特征尺度的影响"></a>特征尺度的影响</h3><p>若各特征量纲差异较大，将导致某些特征主导距离计算结果。<br>常见的解决方法包括：</p><ul><li>Min-Max 归一化；</li><li>Z-score 标准化。</li></ul><p>特征预处理是保证 KNN 算法性能的重要前提。</p><h1 id="KNN优缺点"><a href="#KNN优缺点" class="headerlink" title="KNN优缺点"></a>KNN优缺点</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OTSU</title>
      <link href="/posts/311baf7/"/>
      <url>/posts/311baf7/</url>
      
        <content type="html"><![CDATA[<h1 id="OTSU"><a href="#OTSU" class="headerlink" title="OTSU"></a>OTSU</h1><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/document/4310076">A Threshold Selection Method from Gray-Level Histograms</a></p></blockquote><p>OTSU算法也称<strong>最大类间差法</strong>，有时也称之为大津算法，由大津于1979年提出，被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度分布特性,将图像分成背景(background)和目标(object)两部分。考虑到方差是灰度分布均匀性的一种度量,理想情况下，对于同一类，其类内方差应该是很小的，同时背景和目标之间的类间方差越大,说明构成图像的两部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p><p>该方法的基本思想是根据选取的阈值将图像分为目标和背景两个部分，<strong>通过最大化类间方差（最小化类内方差），自动确定最佳分割阈值</strong></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>假设一幅灰度图像，其灰度级为 $0 \sim L-1$。</p><p>当选择某一阈值 (T) 时，图像被分为两类：</p><ul><li><strong>前景（目标）</strong>：灰度 $0 \sim T$</li><li><strong>背景</strong>：灰度 $T+1 \sim L-1$</li></ul><p>OTSU 的目标是：<br><strong>找到一个阈值 (T)，使得前景与背景的区分度最大</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="灰度直方图概率分布"><a href="#灰度直方图概率分布" class="headerlink" title="灰度直方图概率分布"></a>灰度直方图概率分布</h2><p>设图像共有 $N$ 个像素，灰度级为 $i$，则：<br>$$<br>p_i &#x3D; \frac{n_i}{N}<br>$$</p><ul><li>$n_i$：灰度为 $i$ 的像素数</li><li>$p_i$：灰度 $i$ 出现的概率</li></ul><h2 id="类概率"><a href="#类概率" class="headerlink" title="类概率"></a>类概率</h2><p>对于阈值$T$:</p><ul><li><p>前景概率：<br>$$<br>\omega_0(T) &#x3D; \sum_{i&#x3D;0}^{T} p_i<br>$$</p></li><li><p>背景概率：<br>$$<br>\omega_1(T) &#x3D; \sum_{i&#x3D;T+1}^{L-1} p_i<br>$$</p></li></ul><h2 id="类均值"><a href="#类均值" class="headerlink" title="类均值"></a>类均值</h2><ul><li><p>前景均值：<br>$$<br>\mu_0(T) &#x3D; \frac{1}{\omega_0} \sum_{i&#x3D;0}^{T} i p_i<br>$$</p></li><li><p>背景均值<br>$$<br>\mu_1(T) &#x3D; \frac{1}{\omega_1} \sum_{i&#x3D;T+1}^{L-1} i p_i<br>$$</p></li><li><p>全局均值<br>$$<br>\mu &#x3D; \sum_{i&#x3D;0}^{L-1} i p_i<br>$$</p></li></ul><h2 id="类间方差"><a href="#类间方差" class="headerlink" title="类间方差"></a>类间方差</h2><p>$$<br>\sigma_b^2(T) &#x3D; \omega_0 (\mu_0 - \mu)^2 + \omega_1 (\mu_1 - \mu)^2<br>$$<br>$$<br>&#x3D; \omega_0 \omega_1 (\mu_0 - \mu_1)^2<br>$$</p><h2 id="最优阈值选择"><a href="#最优阈值选择" class="headerlink" title="最优阈值选择"></a>最优阈值选择</h2><p>$$<br>T^* &#x3D; \arg \max_T \sigma_b^2(T)<br>$$</p><p><strong>使类间方差最大的阈值即为 OTSU 阈值</strong></p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ol><li>计算图像灰度直方图</li><li>归一化为概率分布</li><li>遍历所有可能阈值 (T)</li><li>计算类概率、类均值、类间方差</li><li>选择使类间方差最大的阈值</li><li>根据该阈值进行二值化</li></ol><h1 id="底层代码"><a href="#底层代码" class="headerlink" title="底层代码"></a>底层代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">otsu_threshold</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 计算灰度直方图</span></span><br><span class="line">    hist = np.bincount(image.ravel(), minlength=<span class="number">256</span>)</span><br><span class="line">    total = image.size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    prob = hist / total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局均值</span></span><br><span class="line">    mu_total = np.<span class="built_in">sum</span>(np.arange(<span class="number">256</span>) * prob)</span><br><span class="line"></span><br><span class="line">    omega_0 = <span class="number">0.0</span></span><br><span class="line">    mu_0 = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    max_sigma = <span class="number">0.0</span></span><br><span class="line">    best_thresh = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        omega_0 += prob[t]</span><br><span class="line">        mu_0 += t * prob[t]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> omega_0 == <span class="number">0</span> <span class="keyword">or</span> omega_0 == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        omega_1 = <span class="number">1</span> - omega_0</span><br><span class="line">        mu_1 = (mu_total - mu_0) / omega_1</span><br><span class="line">        mu_0_t = mu_0 / omega_0</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 类间方差</span></span><br><span class="line">        sigma_b = omega_0 * omega_1 * (mu_0_t - mu_1) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sigma_b &gt; max_sigma:</span><br><span class="line">            max_sigma = sigma_b</span><br><span class="line">            best_thresh = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_thresh</span><br></pre></td></tr></table></figure><hr><p>参考：<br><a href="https://www.bilibili.com/video/BV1cM8we3EVf?vd_source=59c9078be8272e804fcbbcf1da9a9f94">10.8 大津法（OTSU）（数字图像处理，冈萨雷斯版）</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVD分解</title>
      <link href="/posts/889e03d7/"/>
      <url>/posts/889e03d7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
