<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python开发模式安装</title>
      <link href="/posts/830e646c/"/>
      <url>/posts/830e646c/</url>
      
        <content type="html"><![CDATA[<p><code>python setup.py develop</code> 是 Python 包的<strong>开发模式安装</strong>，核心作用是<strong>将当前项目以 “动态链接” 的方式安装到环境中，而非复制文件</strong>—— 这对需要修改源码的库（如 Dassl.pytorch）至关重要。</p><h1 id="开发模式安装的本质"><a href="#开发模式安装的本质" class="headerlink" title="开发模式安装的本质"></a>开发模式安装的本质</h1><p>当你在 Dassl.pytorch 根目录执行 <code>python setup.py develop</code> 时，会完成以下 3 个关键操作：</p><ol><li><strong>生成包信息文件</strong>：在项目根目录生成 <code>dassl.egg-info</code> 文件夹，包含包的名称、版本、依赖、入口等元数据。</li><li><strong>创建动态链接</strong>：在 conda 环境的 <code>site-packages</code> 目录（如 <code>~/miniforge3/envs/dassl/lib/python3.8/site-packages/</code>）中，创建一个 <strong><code>.egg-link</code> 符号链接文件</strong>，指向你本地的 Dassl.pytorch 源码目录。</li><li><strong>注册可执行脚本（可选）</strong>：如果项目有 <code>console_scripts</code> 配置（如 Dassl 的工具脚本），会在环境的 <code>bin</code> 目录生成可执行文件的链接。</li></ol><h1 id="为什么-Dassl-必须用-develop-模式？"><a href="#为什么-Dassl-必须用-develop-模式？" class="headerlink" title="为什么 Dassl 必须用 develop 模式？"></a>为什么 Dassl 必须用 <code>develop</code> 模式？</h1><p>对比普通安装（<code>python setup.py install</code> 或 <code>pip install .</code>），开发模式的核心优势是 <strong>“源码修改即时生效，无需重新安装”</strong>—— 这对需要二次开发或调试的库（如 Dassl.pytorch）是刚需。</p><h4 id="1-普通安装的问题（不适合-Dassl）"><a href="#1-普通安装的问题（不适合-Dassl）" class="headerlink" title="1. 普通安装的问题（不适合 Dassl）"></a>1. 普通安装的问题（不适合 Dassl）</h4><p>普通安装会将 Dassl 的源码<strong>复制一份</strong>到 conda 环境的 <code>site-packages</code> 目录中。如果你修改了本地的 Dassl 源码（比如改了 <code>dassl/layers/__init__.py</code>），修改不会同步到 <code>site-packages</code> 中的复制版本，必须重新执行 <code>pip install .</code> 才能生效 —— 反复安装会极大降低开发效率。</p><h4 id="2-开发模式的优势（完美适配-Dassl）"><a href="#2-开发模式的优势（完美适配-Dassl）" class="headerlink" title="2. 开发模式的优势（完美适配 Dassl）"></a>2. 开发模式的优势（完美适配 Dassl）</h4><p>开发模式通过<strong>符号链接</strong>指向本地源码，而非复制文件。当你修改本地的 Dassl 源码后，<strong>无需任何额外操作，下次导入 <code>dassl</code> 时，修改会立即生效</strong>。例如：</p><ul><li>你在本地修改了 <code>dassl/engine/trainer.py</code> 中的训练逻辑；</li><li>直接运行依赖 Dassl 的代码（如 Swin Transformer 的训练脚本），新的训练逻辑会被直接调用；</li><li>无需重新安装 Dassl，也无需重启环境。</li></ul><h1 id="与-pip-install-e-的关系（等价命令）"><a href="#与-pip-install-e-的关系（等价命令）" class="headerlink" title="与 pip install -e . 的关系（等价命令）"></a>与 <code>pip install -e .</code> 的关系（等价命令）</h1><p>你在教程中看到的备选命令 <code>pip install -e .</code>，和 <code>python setup.py develop</code> 是<strong>完全等价的</strong>—— 两者都是开发模式安装，只是实现方式不同：</p><ul><li><code>python setup.py develop</code>：通过 <code>setup.py</code> 脚本的内置命令实现，是较老的方式；</li><li><code>pip install -e .</code>：通过 <code>pip</code> 的 <code>editable</code> 模式实现，是较新的推荐方式，兼容性更好（比如在 M 芯片 Mac 上，<code>pip install -e .</code> 通常比 <code>python setup.py develop</code> 更少报错）。</li></ul><h1 id="python-setup-py-develop执行机制"><a href="#python-setup-py-develop执行机制" class="headerlink" title="python setup.py develop执行机制"></a><code>python setup.py develop</code>执行机制</h1><p><strong><code>setuptools/distutils</code> 框架会接管整个执行流程</strong>。</p><ol><li><code>python setup.py develop</code> <strong>必须调用这个 <code>setup.py</code> 文件</strong>—— 命令中的 <code>setup.py</code> 就是指定要执行的脚本路径（默认当前目录的 <code>setup.py</code>）；</li><li>这个脚本<strong>不需要主函数</strong>，因为 <code>setuptools</code> 框架的执行逻辑是：<strong>加载 <code>setup.py</code> 并执行其中的所有顶层代码 → 解析 <code>setup()</code> 函数的配置 → 根据命令行参数（如 <code>develop</code>）执行对应逻辑</strong>；</li><li><code>setup()</code> 函数是整个脚本的「核心入口」，而非传统的 <code>if __name__ == &quot;__main__&quot;</code>。</li></ol><h4 id="步骤-1：Python-解释器加载并执行-setup-py-的「顶层代码」"><a href="#步骤-1：Python-解释器加载并执行-setup-py-的「顶层代码」" class="headerlink" title="步骤 1：Python 解释器加载并执行 setup.py 的「顶层代码」"></a>步骤 1：Python 解释器加载并执行 <code>setup.py</code> 的「顶层代码」</h4><p>当你在终端输入 <code>python setup.py develop</code> 时，Python 解释器会做第一件事：<strong>逐行执行 <code>setup.py</code> 中的所有「顶层代码」</strong>（即不在函数内部的代码），具体包括：</p><ul><li>执行 <code>import numpy as np</code>/<code>import os.path as osp</code>/<code>from setuptools import setup, find_packages</code> → 导入依赖模块；</li><li>执行 <code>def readme(): ...</code>/<code>def find_version(): ...</code> 等函数定义 → 把这些函数加载到内存（但不执行函数体）；</li><li>执行 <code>setup(...)</code> → 这是最关键的一步，<code>setup()</code> 函数会被调用，且 <code>setuptools</code> 会把命令行参数（<code>develop</code>）传递给它。</li></ul><h4 id="步骤-2：setuptools-解析命令行参数（develop）"><a href="#步骤-2：setuptools-解析命令行参数（develop）" class="headerlink" title="步骤 2：setuptools 解析命令行参数（develop）"></a>步骤 2：<code>setuptools</code> 解析命令行参数（<code>develop</code>）</h4><p><code>setup()</code> 函数本身不包含「开发模式安装」的逻辑，它的核心作用是<strong>把你定义的包配置（名称、版本、依赖等）传递给 <code>setuptools</code> 框架</strong>。</p><p>当 <code>setup()</code> 被调用时，<code>setuptools</code> 会：</p><ol><li>读取命令行参数（<code>develop</code>），识别出你要执行「开发模式安装」；</li><li>结合 <code>setup()</code> 中的配置（如 <code>packages=find_packages()</code>、<code>install_requires=get_requirements()</code>），触发 <code>setuptools</code> 内置的 <code>develop</code> 命令逻辑；</li><li>此时，你定义的 <code>find_version()</code>/<code>get_requirements()</code> 等辅助函数才会被<strong>按需调用</strong>（比如 <code>setup()</code> 中的 <code>version=find_version()</code> 会触发 <code>find_version()</code> 执行，<code>install_requires=get_requirements()</code> 会触发 <code>get_requirements()</code> 执行）。</li></ol><h4 id="步骤-3：执行-develop-命令的具体操作（框架内置逻辑）"><a href="#步骤-3：执行-develop-命令的具体操作（框架内置逻辑）" class="headerlink" title="步骤 3：执行 develop 命令的具体操作（框架内置逻辑）"></a>步骤 3：执行 <code>develop</code> 命令的具体操作（框架内置逻辑）</h4><p><code>setuptools</code> 内置的 <code>develop</code> 命令会根据 <code>setup()</code> 的配置，执行我们之前讲过的「开发模式安装」操作：</p><ol><li>调用 <code>find_version()</code> 获取版本号，调用 <code>get_requirements()</code> 获取依赖列表；</li><li>调用 <code>find_packages()</code> 扫描项目中的 Python 包；</li><li>在项目根目录生成 <code>dassl.egg-info</code> 文件夹（包含包元数据）；</li><li>在 conda 环境的 <code>site-packages</code> 目录创建 <code>dassl.egg-link</code> 符号链接（指向本地源码）；</li><li>检查并安装 <code>install_requires</code> 中定义的依赖（如果未安装）；</li><li>完成后返回成功提示。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频谱混叠</title>
      <link href="/posts/df30c197/"/>
      <url>/posts/df30c197/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-“时域”？什么是-“频域”？"><a href="#1-什么是-“时域”？什么是-“频域”？" class="headerlink" title="1. 什么是 “时域”？什么是 “频域”？"></a>1. 什么是 “时域”？什么是 “频域”？</h3><p>时域和频域是<strong>描述同一个信号的两种视角</strong>—— 就像 “描述一首歌”，可以说 “它的旋律随时间怎么变化（时域）”，也可以说 “它包含哪些高低音（频域）”。</p><p>以  <strong>图像（二维信号）</strong> 为例：</p><ul><li><strong>时域</strong>：就是你直接看到的 “像素的亮度随位置的变化”—— 比如一张图里，从左到右像素是 “亮→亮→暗→暗”，这就是 “时域的信号变化”。</li><li>频域：是 “这个变化的‘快慢程度’”——<ul><li>变化<strong>慢</strong>的部分 = 低频：比如大片的蓝色天空，像素亮度几乎不变，属于 “低频信号”；</li><li>变化<strong>快</strong>的部分 = 高频：比如猫的轮廓边缘（从白色毛突然变黑色背景）、细条纹纹理，像素亮度突然跳变，属于 “高频信号”。</li></ul></li></ul><h3 id="2-时域和频域的核心对应关系"><a href="#2-时域和频域的核心对应关系" class="headerlink" title="2. 时域和频域的核心对应关系"></a>2. 时域和频域的核心对应关系</h3><p><strong>时域的 “变化快慢” ↔ 频域的 “频率高低”</strong>：</p><ul><li>时域里 “变化越慢” → 频域里 “频率越低”；</li><li>时域里 “变化越快” → 频域里 “频率越高”。</li></ul><p>举个声音的例子（一维信号）：</p><ul><li>时域：声波随时间的振动波形（比如 “哆来咪” 的波形起伏）；</li><li>频域：这个声音里包含的 “音调高低”—— 低音（比如鼓点）是低频，高音（比如钢琴的高音键）是高频。</li></ul><h3 id="3-为什么频域里-“高频细节会被叠到低频区域”？"><a href="#3-为什么频域里-“高频细节会被叠到低频区域”？" class="headerlink" title="3. 为什么频域里 “高频细节会被叠到低频区域”？"></a>3. 为什么频域里 “高频细节会被叠到低频区域”？</h3><p>这是<strong>频谱混叠</strong>的表现，根源是 “下采样的‘采样速度’跟不上信号的‘变化速度’”（违反了奈奎斯特采样定理）。</p><p>还是用 <strong> 图像的细条纹（高频信号）</strong> 举例：</p><ul><li>时域里：一张图有 “1 像素黑、1 像素白” 的细条纹（变化极快，高频）；</li><li>若用<strong>大步数下采样</strong>（比如一次跳 2 个像素采样）：采样时会 “跳过中间的像素”，原本的 “黑 - 白 - 黑 - 白” 细条纹，可能被采样成 “黑 - 黑” 或 “白 - 白”，看起来像 “粗条纹”（变化慢，低频）；</li><li>对应到频域：原本的 “高频细条纹”，被错误地 “折叠” 到了 “低频粗条纹” 的区域 —— 这就是 “高频细节被叠到低频区域”。</li></ul><p>简单总结：时域是 “信号长什么样”，频域是 “信号由哪些快慢的成分组成”；下采样太快时，频域里快变化的高频成分会被当成慢变化的低频成分，这就是混叠。</p>]]></content>
      
      
      <categories>
          
          <category> 数字信号处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单位超球面</title>
      <link href="/posts/2da7df34/"/>
      <url>/posts/2da7df34/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单位超球面？"><a href="#什么是单位超球面？" class="headerlink" title="什么是单位超球面？"></a>什么是单位超球面？</h1><p>它是“高维空间里的‘单位球面’”，可以从低维例子推广理解： </p><ul><li><p>2维空间：“单位圆”是所有到原点距离为1的点（满足  $x^2 + y^2 = 1$ ）； </p></li><li><p>3维空间：“单位球面”是所有到原点距离为1的点（满足 $x^2 + y^2 + z^2 = 1$ ）； </p></li><li><p>高维空间（比如d维，(d&gt;3)）：“超球面”是高维空间的球面结构，<strong>单位超球面</strong>就是所有到原点距离为1的点的集合，对应向量的L₂范数（模长）为1，公式是： $  |\boldsymbol{v}|_2 = \sqrt{v_1^2 + v_2^2 + \dots + v_d^2} = 1  $</p></li></ul><h1 id="CLIP为什么要让嵌入向量分布在单位超球面？"><a href="#CLIP为什么要让嵌入向量分布在单位超球面？" class="headerlink" title="CLIP为什么要让嵌入向量分布在单位超球面？"></a>CLIP为什么要让嵌入向量分布在单位超球面？</h1><p>CLIP的核心是计算“图像嵌入”和“文本嵌入”的匹配度，用的是<strong>余弦相似度</strong>，公式是：</p><script type="math/tex; mode=display">\text{余弦相似度} = \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{\|\boldsymbol{u}\|_2 \cdot \|\boldsymbol{v}\|_2}</script><p>当嵌入向量经过 $L₂$ 归一化（模长=1，即落在单位超球面）时，分母为 $1 \times 1 = 1$，此时<strong>向量的点积</strong> $ \boldsymbol{u} \cdot \boldsymbol{v} $ 就直接等于余弦相似度。 这一步的作用是：排除向量“长度”的干扰，只通过向量之间的“夹角”衡量语义匹配度——夹角越小，点积（相似度）越大，说明图像和文本的语义越一致。 </p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SLAM</title>
      <link href="/posts/6073489d/"/>
      <url>/posts/6073489d/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1byKAewEUm?vd_source=59c9078be8272e804fcbbcf1da9a9f94">01  SLAM简介与应用场景</a></p><p>《SLAM十四讲（视觉）》</p><p>VIO</p><hr><h1 id="SLAM简介"><a href="#SLAM简介" class="headerlink" title="SLAM简介"></a>SLAM简介</h1><p><a href="https://www.bilibili.com/video/BV1byKAewEUm?vd_source=59c9078be8272e804fcbbcf1da9a9f94">01  SLAM简介与应用场景</a></p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FAST-LIO</title>
      <link href="/posts/c325d296/"/>
      <url>/posts/c325d296/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1eu4y1o7pQ?vd_source=59c9078be8272e804fcbbcf1da9a9f94">香港大学开源FAST-LIO简介，对比及学习方法</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FAST-LIVO2</title>
      <link href="/posts/a2ded50b/"/>
      <url>/posts/a2ded50b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1TTCxBoEz7?vd_source=59c9078be8272e804fcbbcf1da9a9f94"> FAST-LIVO2</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高光谱相机</title>
      <link href="/posts/d1ad4bd1/"/>
      <url>/posts/d1ad4bd1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.csgpc.org/detail/21288.html">什么是高光谱？</a></p><p><a href="https://www.specim.com/cn/hyperspectral-imaging-applications/">高光谱应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 相机成像 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相机</title>
      <link href="/posts/9fbcc97b/"/>
      <url>/posts/9fbcc97b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/410476294">特种相机（一）—— 多光谱相机（基础篇）</a></p><hr><h1 id="光谱波段"><a href="#光谱波段" class="headerlink" title="光谱波段"></a>光谱波段</h1><p>光学领域中基于<strong>电磁波波长范围</strong>划分的<strong>光谱波段</strong>，广泛应用于计算机视觉、遥感、机器人感知（包括 SLAM）等领域。</p><div class="table-container"><table><thead><tr><th style="text-align:center">波段名称</th><th style="text-align:center">波长范围</th><th style="text-align:center">能量范围</th><th style="text-align:center">核心特性</th><th style="text-align:center">典型应用</th></tr></thead><tbody><tr><td style="text-align:center">伽马射线（γ）</td><td style="text-align:center">&lt; 0.01 nm</td><td style="text-align:center">&gt; 124 keV</td><td style="text-align:center">能量极高，穿透能力极强，可电离物质</td><td style="text-align:center">核物理、天体物理、医疗放疗</td></tr><tr><td style="text-align:center">伦琴射线（X 射线）</td><td style="text-align:center">0.01 nm ~ 10 nm</td><td style="text-align:center">124 eV ~ 124 keV</td><td style="text-align:center">能量高，穿透能力强，可穿透人体和金属</td><td style="text-align:center">医学成像、工业无损检测、安检</td></tr><tr><td style="text-align:center">紫外线（UV）</td><td style="text-align:center">10 nm ~ 400 nm</td><td style="text-align:center">3.1 eV ~ 124 eV</td><td style="text-align:center">能量高于可见光，可使荧光物质发光，具有杀菌作用，易被臭氧层吸收</td><td style="text-align:center">紫外成像、杀菌消毒、光刻技术</td></tr><tr><td style="text-align:center"><strong>可见光（VIS）</strong></td><td style="text-align:center">400 nm ~ 700 nm</td><td style="text-align:center">1.77 eV ~ 3.1 eV</td><td style="text-align:center">人类肉眼可见，是传统视觉的核心波段，纹理信息丰富</td><td style="text-align:center">普通 RGB 相机、SLAM、机器视觉</td></tr><tr><td style="text-align:center">红外线（IR）</td><td style="text-align:center">700 nm ~ 1 mm</td><td style="text-align:center">1.24 meV ~ 1.77 eV</td><td style="text-align:center">肉眼不可见，具有热辐射特性，按波长可进一步细分为近、中、长、远红外</td><td style="text-align:center">红外成像、热成像、遥感、SLAM</td></tr><tr><td style="text-align:center">微波（Microwave）</td><td style="text-align:center">1 mm ~ 1 m</td><td style="text-align:center">1.24 μeV ~ 1.24 meV</td><td style="text-align:center">波长较长，穿透能力强，不易受天气影响</td><td style="text-align:center">雷达、卫星通信、微波炉</td></tr><tr><td style="text-align:center">无线电波（Radio）</td><td style="text-align:center">&gt; 1 m</td><td style="text-align:center">&lt; 1.24 μeV</td><td style="text-align:center">波长最长，传播距离远，绕射能力强</td><td style="text-align:center">广播、电视、移动通信、导航</td></tr></tbody></table></div><h2 id="红外"><a href="#红外" class="headerlink" title="红外"></a>红外</h2><div class="table-container"><table><thead><tr><th style="text-align:center">子波段名称</th><th style="text-align:center">波长范围</th><th style="text-align:center">英文缩写</th><th style="text-align:center">工程别名</th><th style="text-align:center">关键特性</th><th style="text-align:center">成像技术</th><th style="text-align:center">典型应用场景（SLAM 相关）</th></tr></thead><tbody><tr><td style="text-align:center">近红外（Near-Infrared）</td><td style="text-align:center">700 nm ~ 1100 nm</td><td style="text-align:center">NIR</td><td style="text-align:center">反射红外、NIR-I</td><td style="text-align:center">与可见光相邻，普通 CMOS 传感器可响应（需去红外截止滤镜），依赖环境反射光，纹理丰富</td><td style="text-align:center">近红外相机、改装 RGB 相机</td><td style="text-align:center">低光照 SLAM、雾霾场景 SLAM、RGB-NIR 融合 SLAM</td></tr><tr><td style="text-align:center">扩展近红外（Extended NIR）</td><td style="text-align:center">1100 nm ~ 1700 nm</td><td style="text-align:center">NIR-II</td><td style="text-align:center">短波近红外</td><td style="text-align:center">穿透能力强于 NIR-I，可穿透薄雾、玻璃，需要专用 InGaAs 传感器</td><td style="text-align:center">扩展近红外相机</td><td style="text-align:center">玻璃遮挡 SLAM、强雾霾 SLAM</td></tr><tr><td style="text-align:center">短波红外（Short-Wave IR）</td><td style="text-align:center">1700 nm ~ 2500 nm</td><td style="text-align:center">SWIR</td><td style="text-align:center">近红外 - II、SWIR</td><td style="text-align:center">穿透能力极强，可穿透厚雾、沙尘、玻璃，依赖反射光，能区分材料光谱特征</td><td style="text-align:center">InGaAs 传感器相机</td><td style="text-align:center">极端环境 SLAM、工业检测 SLAM</td></tr><tr><td style="text-align:center">中波红外（Mid-Wave IR）</td><td style="text-align:center">2.5 μm ~ 5 μm</td><td style="text-align:center">MWIR</td><td style="text-align:center">中红外、热红外 - I</td><td style="text-align:center">不依赖环境光，可检测物体自身的热辐射（温度 &gt; 300K），穿透能力强于 LWIR</td><td style="text-align:center">制冷型红外传感器</td><td style="text-align:center">夜间 SLAM、热成像 SLAM、火灾检测 SLAM</td></tr><tr><td style="text-align:center">长波红外（Long-Wave IR）</td><td style="text-align:center">5 μm ~ 15 μm</td><td style="text-align:center">LWIR</td><td style="text-align:center">远红外、热红外 - II</td><td style="text-align:center">检测物体自身热辐射（温度 &gt; 0K），成像分辨率高，成本低于 MWIR，易受大气水汽影响</td><td style="text-align:center">非制冷型红外传感器</td><td style="text-align:center">夜间 SLAM、安防 SLAM、自动驾驶热成像 SLAM</td></tr><tr><td style="text-align:center">远红外（Far-Infrared）</td><td style="text-align:center">15 μm ~ 1 mm</td><td style="text-align:center">FIR</td><td style="text-align:center">极远红外</td><td style="text-align:center">波长最长，热辐射能量低，成像分辨率低，易被大气吸收</td><td style="text-align:center">专用远红外传感器</td><td style="text-align:center">天体物理、工业加热检测</td></tr></tbody></table></div><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><div class="table-container"><table><thead><tr><th>缩写</th><th>全称</th><th>波长范围</th><th>关键特性</th></tr></thead><tbody><tr><td>VIS</td><td>Visible Light（可见光）</td><td>400 nm ~ 700 nm</td><td>人类肉眼可见的波段，依赖环境光照，成像色彩丰富、纹理细节清晰，但易受光照变化、雾霾、遮挡影响</td></tr><tr><td>VISNIR</td><td>Visible-Near Infrared（可见光 - 近红外）</td><td>400 nm ~ 1100 nm</td><td>覆盖 VIS 和 NIR 两个波段，结合了可见光的纹理优势和近红外的低光照适应性，是<strong>多光谱相机的常用组合</strong></td></tr><tr><td>NIR-SWIR</td><td>Near Infrared-Short-Wave Infrared（近红外 - 短波红外）</td><td>700 nm ~ 2500 nm</td><td>覆盖 NIR 和 SWIR 两个波段，均为不可见光，穿透能力强（可穿透薄雾、水汽、部分非金属材料），不受可见光干扰，但成像分辨率相对较低，需要专用传感器</td></tr></tbody></table></div><h1 id="相机成像物理技术"><a href="#相机成像物理技术" class="headerlink" title="相机成像物理技术"></a>相机成像物理技术</h1><p><strong>不同光谱波段的信息，本质上来自于：</strong><br> <strong>物体对不同波长光的反射 / 吸收 / 透射特性不同，相机通过“光谱选择机制”把这些差异分离并记录下来。</strong></p><script type="math/tex; mode=display">I(λ)=E(λ)⋅R(λ)⋅S(λ)</script><ul><li>$E(\lambda)$：光源在波长 $\lambda $ 处的能量</li><li>$R(\lambda)$：物体在 $\lambda $ 处的反射率（你真正想要的）</li><li>$S(\lambda)$：相机/传感器在 $\lambda$ 处的响应</li></ul><h2 id="RGB-成像"><a href="#RGB-成像" class="headerlink" title="RGB 成像"></a>RGB 成像</h2><p>完整流程：</p><ol><li><strong>宽谱白光</strong>（太阳 / LED）照射物体</li><li>物体对不同波长的光反射不同</li><li>反射光进入相机镜头</li><li><strong>相机内部的 RGB 滤光结构，把光谱分成 R / G / B</strong></li><li>传感器分别记录三个波段的强度</li></ol><p>RGB相机分离光谱：<br>Bayer滤光片阵列，每个物理像素只看到一个波段，通过插值重建：$Pixel(x,y)=(R,G,B)$</p><blockquote><ol><li><strong>拜耳滤色器阵列（CFA）</strong></li></ol><p>在传感器的每个物理像素上面，只盖了<strong>一个颜色的滤光片</strong>（要么 R、要么 G、要么 B）。比如：</p><ul><li>某个物理像素上盖了 “红色滤光片”，它就只能接收红光，所以这个像素的原始输出只有 “R 通道的值”，G、B 通道是没有数据的；</li><li>旁边的像素盖了 “绿色滤光片”，原始输出就只有 “G 通道的值”，R、B 是空的。</li></ul><p>所以传感器直接输出的 “原始数据”，是一张 “马赛克状” 的图：每个物理像素只有 1 个颜色值，另外 2 个颜色值是缺失的。而我们最终看到的 “每个像素有 R、G、B 三个通道” 的彩色图，是<strong>去马赛克算法把周围像素的同颜色值插值补全后得到的结果</strong>—— 相当于用周围的 R 值补上当前像素的 R 值（如果它本身是 G 的话），以此类推，把每个像素的 3 个通道都填完整。<br>即：</p><blockquote><p>物理像素 + 单个滤光片 → 每个像素只采 1 个通道（原始数据）；</p><p>去马赛克算法插值补全 → 每个像素拥有 3 个通道（最终彩色图像）。</p></blockquote><ol><li>滤光片排布</li></ol><p><strong>滤光片的排布是固定规律的</strong>—— 核心逻辑是 “人眼对绿色更敏感，所以 G 滤光片的占比更高（50%），R 和 B 各占 25%”。</p><p>最常用的是<strong>RGGB 排布（也是默认的拜耳模式）</strong>，具体规律是：</p><ul><li>奇数行（第 1、3、5… 行）：按 “R→G→R→G…” 交替排列；</li><li>偶数行（第 2、4、6… 行）：按 “G→B→G→B…” 交替排列。</li></ul><ol><li><strong>去马赛克算法</strong></li></ol><p><strong>用周围像素的同通道信息，插值补全当前像素的缺失通道</strong>。比如，某个像素只有 “红色（R）” 值，算法会参考它上下左右像素的 “绿色（G）”“蓝色（B）” 值，通过双线性插值、自适应插值等方式，算出这个像素的 G 和 B 值；最终把每个像素的 R、G、B 三个通道都补全，得到完整的彩色图像。</p></blockquote><h2 id="多光谱成像"><a href="#多光谱成像" class="headerlink" title="多光谱成像"></a>多光谱成像</h2><p>在 RGB 的基础上，把“3 个滤波器”变成 “N 个滤波器”</p><h3 id="滤光轮相机"><a href="#滤光轮相机" class="headerlink" title="滤光轮相机"></a>滤光轮相机</h3><p><img src="https://pic3.zhimg.com/v2-aef31755825d76bdbbd8539dbb3ef01e_1440w.jpg" alt=""></p><p>原理：</p><ul><li>在镜头前放一个<strong>滤光片</strong></li><li>每次只允许一个波段的光通过</li><li>轮流拍摄</li></ul><p>通过旋转安装在传感器或镜头前面的滤光轮中的滤光片来捕获多通道光谱图像。这种滤光轮通常可以支持多达 12 个波段。然后从多光谱图像估计每像素光谱反射率。基于滤光轮的相机的优点是每个波段的全空间分辨率，而且滤光片可以根据应用要求定制和更换。<br>该系统的缺点包括成像速度慢且耗时、图像配准复杂、几何失真不好校正等。此外，还存在系统中包含机械运动部件（电动轮）的问题，长时间使用会降低精度甚至损坏，因此需要定期维护或更换。</p><h3 id="像素化多光谱滤波器阵列（快照式，多光谱-Bayer）"><a href="#像素化多光谱滤波器阵列（快照式，多光谱-Bayer）" class="headerlink" title="像素化多光谱滤波器阵列（快照式，多光谱 Bayer）"></a>像素化多光谱滤波器阵列（快照式，多光谱 Bayer）</h3><p><img src="https://pica.zhimg.com/v2-713aeb2d53b19d9e8ecf5eb02657d734_1440w.jpg" alt=""></p><p>原理：</p><ul><li>像 RGB Bayer 一样</li><li>但每个像素对应 <strong>不同波段（如 8/16 个）</strong></li></ul><p>是传统拜耳滤色器阵列（CFA，RGB 三通道）的扩展版。</p><ul><li>传统 Bayer（CFA）：每个像素对应 RGB 其中一个通道，单次拍摄后通过插值（去马赛克）得到全彩图像；</li><li>这里的多光谱滤光器阵列（MSFA）：把 Bayer 的 “RGB 三通道” 扩展成多光谱通道（4~40 个，覆盖 VIS、VISNIR 等波段），同样是 <strong>单次拍摄（快照式）</strong> 获取多光谱数据，再通过去马赛克算法重建各波段图像，所以也被称为 “多光谱 Bayer 结构”。</li></ul><p>这种捕获方法也称为快照马赛克成像。快照马赛克传感器可以支持 VIS（可见光）、VISNIR 和 NIR-SWIR 波长中 4 到 40 个通道之间的任何通道。<br>该方案的缺点：第一，在批量制造中实现非常高的像素一致性一直具有挑战性。第二，波段可能具有相对较高的串扰，这会影响整体光谱灵敏度、像素噪声参数和光谱重建的准确性。第三， 由于滤波器阵列中每个光谱带的采样较为稀疏，频段越多，每个频段的空间精度就越低。此外，多光谱滤波器阵列的去马赛克算法一直是一个具有挑战性的问题。</p><h3 id="多传感器二向色棱镜相机（分光棱镜并行采集）"><a href="#多传感器二向色棱镜相机（分光棱镜并行采集）" class="headerlink" title="多传感器二向色棱镜相机（分光棱镜并行采集）"></a>多传感器二向色棱镜相机（分光棱镜并行采集）</h3><p><img src="https://pic2.zhimg.com/v2-7486d749a07d122296aca175e4f9d4fb_1440w.jpg" alt=""></p><p><strong>靠 “二向色棱镜的涂层” 把入射光按波长拆分，让不同波段的光分别落到独立的传感器上，实现多光谱的 “并行全分辨率采集”</strong>。</p><p>原理：</p><ol><li><p><strong>入射光进入棱镜系统</strong>：镜头（Optics）收集的混合光（包含 VIS、NIR 等多波段）先进入二向色棱镜块。</p></li><li><p><strong>二向色涂层分光</strong>：棱镜表面的 “硬二向色涂层” 是核心 —— 它本质是<strong>精准的干涉滤光片</strong>：</p><ul><li><p>对某一波长范围的光（比如 R 波段），涂层会 “反射” 它，让这束光转向对应的传感器；</p></li><li><p>对另一波长范围的光（比如 G、B 波段），涂层会 “透射” 它，让光继续穿过棱镜，直到下一层涂层再拆分到对应的传感器。</p></li></ul><blockquote><p>二向色涂层：</p><p><strong>它能对不同波长的光，选择性地做 “反射” 或 “透射” 两种操作</strong>，而不是像普通滤光片那样 “吸收不需要的光”。</p><p>本质是一种<strong>精准的干涉滤光结构</strong>—— 它会对某一波长范围的光（比如 VIS 波段的红光）做 “反射”，把这束光导向对应的传感器；同时对另一波长范围的光（比如 NIR 波段的光）做 “透射”，让这束光穿过涂层，继续进入棱镜的下一层，直到被下一层二向色涂层拆分到另一个传感器。</p><p>根据需要拆分的波段数量，涂多层二向色涂层。</p></blockquote></li><li><p><strong>多传感器并行采集</strong>：每一个传感器只接收 “被棱镜分到自己这里的特定波段光”，且每个传感器都是<strong>全像素采集该波段</strong>（比如 G 波段传感器的所有像素都只收 G 光）。</p></li></ol><p>优势：</p><ul><li>不需要去马赛克算法：每个传感器直接输出对应波段的完整图像（全空间分辨率）；</li><li>光能利用率高：二向色涂层是 “分而不浪费”，不像 MSFA 的滤光片会过滤掉大部分光；</li><li>帧率 / 分辨率表现好：面扫描下能做到 3.2MP+100fps 的多波段同步采集。</li></ul><h3 id="多线相机（基于线扫描传感器）"><a href="#多线相机（基于线扫描传感器）" class="headerlink" title="多线相机（基于线扫描传感器）"></a>多线相机（基于线扫描传感器）</h3><p><img src="https://pic1.zhimg.com/v2-a734692b288e7100363a9741e8c3d36e_1440w.jpg" alt=""></p><p>原理：</p><p>线扫描相机的本质是 “逐行采集图像”（比如工业检测中常用来扫连续物体），而多线相机是给它加了<strong>多条平行的像素线</strong>，且<strong>每条像素线都配了独特的光谱带通滤光片</strong>：</p><ul><li>每条线只允许对应波段的光通过（比如第一条线过 R 光、第二条过 G 光、第三条过 B 光）；</li><li>当相机扫描目标时，每条线会同步采集 “对应波段的一行数据”，最终把所有线的行数据拼接起来，就能得到多光谱图像。</li></ul><p>例如：</p><p>四线多线相机：</p><ol><li><p>四线传感器的 “同步采集一行场景的 4 个波段”</p><p>四线相机的传感器上，有<strong>4 条平行且紧密排列的像素线</strong>，每条线都配了专属的波段滤光片（比如线 1=B、线 2=G、线 3=R、线 4=NIR）。</p><p>当相机对准目标时，<strong>这 4 条线会同时接收 “场景中同一行位置” 的光</strong>：</p><ul><li>线 1（B 滤光片）→ 采集该场景行的 B 波段像素行数据；</li><li>线 2（G 滤光片）→ 采集同一场景行的 G 波段像素行数据；</li><li>线 3（R 滤光片）→ 采集同一场景行的 R 波段像素行数据；</li><li>线 4（NIR 滤光片）→ 采集同一场景行的 NIR 波段像素行数据。</li></ul></li><li><p>相对运动，累积多组 “四行数据”</p><p>因为四线传感器只有 4 条线，无法一次拍全整个场景，所以需要<strong>相机和目标之间做匀速相对运动</strong>（比如相机沿垂直于像素线的方向向前移动，或目标匀速经过相机）。</p><p>每移动一个 “行间距” 的距离，相机就会再次采集一组新的 “4 条像素行数据”（对应场景的下一行位置）。不断重复这个过程，就能累积到<strong>成百上千组四行数据</strong>。</p></li><li><p>分波段拼接，得到 4 张完整的单波段图像</p><p>累积足够的四行数据后，软件会按<strong>波段分类</strong>进行拼接：</p><ul><li>把所有采集到的 “B 波段像素行数据” 按顺序拼接 → 得到完整的 B 波段图像；</li><li>把所有 “G 波段像素行数据” 拼接 → G 波段图像；</li><li>同理，得到 R 波段和 NIR 波段的完整图像。</li></ul></li></ol><h3 id="用于多光谱成像（线扫描）的推扫式相机"><a href="#用于多光谱成像（线扫描）的推扫式相机" class="headerlink" title="用于多光谱成像（线扫描）的推扫式相机"></a>用于多光谱成像（线扫描）的推扫式相机</h3><p><img src="https://pic4.zhimg.com/v2-476c8c60be3321a362e7e440505ae9f3_r.jpg" alt=""></p><ol><li><p>组成</p><p>镜头、成像光谱仪和硅基图像传感器（在 VIS-NIR 的情况下）或 InGaAs 传感器（在 NIR-SWIR 的情况下）。成像光谱仪由光色散单元和聚焦光学器件组成，构成推扫式相机的关键部件。内成像光谱仪，光线通过输入狭缝、准直器，到达色散单元，然后聚焦到图像传感器上，提供单条线的 x-λ 坐标。</p></li><li><p>原理</p><p>采用 “x-λ 扫描”：同时覆盖水平分辨率和多个波长带，沿传输方向（y 轴）顺序扫描，逐行捕获完整的空间 + 光谱信息。可以逐行捕获完整的空间和光谱信息。</p></li></ol><h2 id="多光谱VS高光谱"><a href="#多光谱VS高光谱" class="headerlink" title="多光谱VS高光谱"></a>多光谱VS高光谱</h2><p><img src="https://pic3.zhimg.com/v2-65b8d1a76245a8d612f48b2f7db2fb5e_1440w.jpg" alt="高光谱成像提供一段准连续范围的光谱"></p><p><img src="https://pic1.zhimg.com/v2-8473de809d4e12cbdfdf0bde9f87b54c_1440w.jpg" alt="多光谱成像由彼此离散定位的光谱带组成"></p><div class="table-container"><table><thead><tr><th style="text-align:center">维度</th><th style="text-align:center">多光谱（Multispectral）</th><th style="text-align:center">高光谱（Hyperspectral）</th></tr></thead><tbody><tr><td style="text-align:center">波段数量</td><td style="text-align:center">通常是 <strong>几个到几十个</strong>（比如 5-30 个）</td><td style="text-align:center">通常是 <strong>几十到几百个</strong>（比如 100-224 个，甚至更多）</td></tr><tr><td style="text-align:center">波段宽度</td><td style="text-align:center">较宽，一般 <strong>10-100 纳米</strong>（比如可见光里的 “红、绿、蓝” 就是宽波段）</td><td style="text-align:center">极窄，一般 <strong>1-10 纳米</strong>（能细分到连续的光谱区间）</td></tr><tr><td style="text-align:center">数据维度</td><td style="text-align:center">生成 “二维空间 + 少数光谱波段” 的简单数据</td><td style="text-align:center">生成 “二维空间 + 连续光谱维度” 的 “数据立方体”</td></tr><tr><td style="text-align:center">成像原理</td><td style="text-align:center">常用<strong>带通滤光片</strong>（比如给不同线阵配不同滤光片），直接过滤出几个特定波段的光，采集对应数据</td><td style="text-align:center">常用<strong>成像光谱仪</strong>（分光元件），把光分成连续的窄波段，再由传感器逐波段采集，能覆盖更精细的光谱区间</td></tr></tbody></table></div><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 相机成像 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>边缘计算</title>
      <link href="/posts/7beec643/"/>
      <url>/posts/7beec643/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是边缘计算"><a href="#什么是边缘计算" class="headerlink" title="什么是边缘计算"></a>什么是边缘计算</h1><p>边缘计算是一种致力于使计算尽可能靠近数据源、以减少延迟和带宽使用的网络理念，是一种<strong>把数据处理、存储等任务放到 “靠近数据源的边缘节点”</strong>（而不是全集中在云端）的技术架构。简而言之，边缘计算意味着在云端运行更少的进程，将这些进程移动到本地，例如用户的计算机、<a href="https://www.cloudflare.com/learning/cloud/what-is-the-cloud/">IoT 设备</a>或<a href="https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/">边缘服务器</a>。将计算放到网络边缘可以最大程度地减少<a href="https://www.cloudflare.com/learning/serverless/glossary/client-side-vs-server-side/">客户端和服务器</a>之间必须进行的长距离通信量。</p><blockquote><p>网络边缘：<br>对于互联网设备，网络边缘是设备或包含设备的本地网络与互联网通信的位置。边缘是个比较模糊的术语。例如，可以将用户的计算机或 IoT 摄像头内部的处理器视为网络边缘，但也可以将用户的路由器、ISP 或本地边缘服务器视为边缘。重要的是，网络边缘在地理位置上靠近设备，与<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源站</a>和云服务器不同，后者可能与它们相互通信的设备相距很远。</p></blockquote><h1 id="边缘计算与其他计算模型"><a href="#边缘计算与其他计算模型" class="headerlink" title="边缘计算与其他计算模型"></a>边缘计算与其他计算模型</h1><p><strong>最早期的计算机</strong>是巨大笨重的机器，只能直接访问或通过终端访问，这些终端基本上是计算机的扩展。随着<strong>个人计算机</strong>的发明，计算可以用一种更加分散的方式进行。曾几何时，个人计算是占主导地位的计算模式。应用程序在本地运行，数据存储于用户的设备上，有时在本地数据中心内。</p><p><strong>云计算</strong>是更新的发展，与这种基于本地的计算相比，它提供了许多优势。云服务集中在供应商管理的“云”(或数据中心的集合)中，可以从互联网上的任何设备访问。</p><p>但是，由于用户与托管云服务的数据中心之间的距离，云计算可能会引入<a href="https://www.cloudflare.com/learning/performance/glossary/what-is-latency/">延迟</a>。<strong>边缘计算</strong>使计算更接近最终用户，以最小化数据必须传输的距离，同时仍然保留云计算的集中化性质。</p><p>总而言之：</p><ul><li>早期计算：集中式应用程序，仅在一台孤立的计算机上运行</li><li>个人计算：本地运行的去中心化应用程序</li><li>云计算：在数据中心运行的集中式应用程序</li><li>边缘计算：在靠近用户的地方——设备本身或者网络边缘——运行的集中式应用程序</li></ul><h1 id="边缘计算应用"><a href="#边缘计算应用" class="headerlink" title="边缘计算应用"></a>边缘计算应用</h1><h2 id="安全系统监控"><a href="#安全系统监控" class="headerlink" title="安全系统监控"></a>安全系统监控</h2><p><strong>让摄像头本地运行运动检测程序</strong>，只把“有活动的视频片段”传到云服务器，而不是全量传原始视频。</p><p> 解决的问题：既省了大量带宽（不用传没动静的冗余视频），又减轻了云服务器的处理/存储负载，还能更快响应异常情况。  </p><h2 id="IoT设备"><a href="#IoT设备" class="headerlink" title="IoT设备"></a>IoT设备</h2><p>比如智能音箱、智能门锁这类设备：<strong>把简单的指令处理代码放到设备本地运行</strong>，不用每次都把数据传到云端再等结果。 </p><p>举个例子：智能音箱收到“调低音量”的指令，本地直接执行操作，不用等云端解析反馈；智能门锁本地识别指纹/密码，不用连网才能开门。 </p><p>解决的问题：交互延迟大幅降低，设备响应更流畅，甚至断网时基础功能也能正常用。  </p><h2 id="自动驾驶汽车"><a href="#自动驾驶汽车" class="headerlink" title="自动驾驶汽车"></a>自动驾驶汽车</h2><p>自动驾驶依赖摄像头、雷达等传感器的实时数据：<strong>把决策代码放到汽车自带的车载计算单元（边缘节点）本地运行</strong>，不用等数据传到云端处理再发指令。</p><p> 比如遇到突然窜出的行人，车载计算单元能毫秒级完成“识别→判断→刹车”的流程；要是等云端指令，延迟早就让事故发生了。 </p><p>解决的问题：满足自动驾驶的“实时响应”刚需，保障行驶安全。  </p><h2 id="更高效的缓存（结合CDN）"><a href="#更高效的缓存（结合CDN）" class="headerlink" title="更高效的缓存（结合CDN）"></a>更高效的缓存（结合CDN）</h2><p> CDN是分布在各地的“边缘服务器”（本来是存图片、视频的），边缘计算让它不仅能存内容，还能<strong>本地运行代码自定义缓存逻辑</strong>。</p><p>比如视频网站，会根据你所在的区域、常看的内容，让你附近的CDN边缘服务器提前缓存你可能要看的片段；你打开视频时，直接从近的边缘服务器拿内容，不用从遥远的云服务器拉取。 </p><p>解决的问题：内容加载速度更快，也省了跨区域传输的带宽。  </p><h2 id="医疗监控设备"><a href="#医疗监控设备" class="headerlink" title="医疗监控设备"></a>医疗监控设备</h2><p>比如重症病人的心率监护仪、呼吸机：<strong>把“异常数据检测”的代码放到设备本地运行</strong>，不用等数据传到云端再判断报警。</p><p>比如心率突然超标时，设备本地直接触发报警，同时再把数据同步到云；要是等云端反馈，可能耽误抢救时机。 </p><p>解决的问题：满足医疗场景的“实时响应”刚需，避免关键信息延迟。  </p><h2 id="视频会议"><a href="#视频会议" class="headerlink" title="视频会议"></a>视频会议</h2><p>多人视频会议的视频流很占带宽：<strong>把“视频压缩、流转发”的进程放到离参会者近的边缘节点运行</strong>，而不是全传到云端集中处理。 </p><p>比如你在北京开会，视频流先传到北京的边缘节点压缩、转发，不用传到千里之外的云服务器再分发。 </p><p>解决的问题：减少数据传输的距离和带宽消耗，会议延迟更低、更流畅。 </p><h1 id="边缘计算优势"><a href="#边缘计算优势" class="headerlink" title="边缘计算优势"></a>边缘计算优势</h1><ul><li>减少延迟</li><li>减少带宽使用和相关成本</li><li>减少服务器资源消耗和相关成本</li><li>增加功能</li></ul><h2 id="节省成本"><a href="#节省成本" class="headerlink" title="节省成本"></a>节省成本</h2><p>边缘计算有助于最大程度地减少带宽使用量和服务器资源消耗。带宽和云资源是有限的，并且需要花费成本。Statista <a href="https://www.statista.com/statistics/471264/iot-number-of-connected-devices-worldwide/">预测</a>，随着每个家庭和办公室都配备智能相机、打印机、温度调节装置甚至烤面包机，到 2025 年，全球将安装超过 750 亿个 IoT 设备。为了支持所有这些设备，必须将大量计算移到边缘。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>将流程移至边缘的另一个重要优势是减少延迟。设备每次需要与某处的远程服务器通信时，都会造成延迟。例如，同一办公室中的两个同事在 IM 平台上聊天可能会遇到相当大的延迟，因为设备必须将每条消息路由到建筑物外，与全球某处的服务器通信，然后再传回，最后才能出现在收信人的屏幕上。如果将该过程放到边缘，并且由公司的内部路由器负责传输办公室内的聊天记录，则不会出现明显的延迟。</p><p>同样，当各种 Web 应用的用户遇到必须与外部服务器进行通信的进程时，他们将感受到延迟。这些延迟的持续时间将根据可用带宽和服务器的位置而变化，但是可以通过将更多进程引入网络边缘来完全避免这些延迟。</p><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><p>此外，边缘计算可以提供以前无法提供的新功能。例如，公司可以使用边缘计算在边缘处理和分析数据，使得实时处理成为可能。</p><p>完全减轻额外硬件需求的一种方法是利用边缘服务器。例如，借助 Cloudflare 分散在全球各地的 330 个边缘服务器组成的网络，Cloudflare 的客户可以使用 <a href="https://www.cloudflare.com/products/cloudflare-workers/">Cloudflare Workers</a> 在全球范围内运行边缘代码。</p><h1 id="边缘计算缺点"><a href="#边缘计算缺点" class="headerlink" title="边缘计算缺点"></a>边缘计算缺点</h1><p>边缘计算的一个缺点是会增加<a href="https://www.cloudflare.com/learning/security/glossary/attack-vector/">攻击媒介</a>。随着更多“智能”设备的加入，例如具有强大内置计算机的边缘服务器和 IoT 设备，给恶意攻击者带来入侵这些设备的新机会。</p><p>边缘计算的另一个缺点是它需要更多的本地硬件。例如，虽然 IoT 摄像头需要内置计算机才能将原始视频数据发送到 Web 服务器，但如果要运行自己的运动检测算法，就需要一台功能更强大、有更大处理能力的复杂计算机。但是，硬件成本的下降使得构建更智能设备的成本变得更为低廉。</p><hr><blockquote><p><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/what-is-edge-computing/">https://www.cloudflare.com/zh-cn/learning/serverless/glossary/what-is-edge-computing/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪代码</title>
      <link href="/posts/ce589481/"/>
      <url>/posts/ce589481/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言(C, Java, Pascal)实现。因此，伪代码必须结构清晰，代码简单，可读性好，并且类似自然语言。</p><p><strong>伪代码的优点</strong></p><ul><li><p>提高任何方法的可读性。这是开始实现算法的最佳方法之一。</p></li><li><p>充当程序与算法或流程图之间的桥梁。也可以作为一个粗略的文档，因此当写出伪代码时，可以很容易地理解一个开发人员的程序。在行业中，文档是必不可少的。这就是证明伪代码至关重要的地方。</p></li><li><p>伪代码的主要目标是解释程序的每一行应该做什么，从而使程序员更容易构建代码构建阶段。</p></li></ul><h1 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h1><ul><li>在伪代码中，<strong>每一条指令占一行</strong>(else if 例外)，指令后不跟任何符号；</li><li><strong>“缩进”</strong> 表示程序中的分支程序结构（同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进）；</li><li>通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上行号，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤；</li><li>每一行可以加上编号（也可不加）。</li></ul><h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>算法中出现的数组、变量可以是：整数、实数、字符、字符串、指针。在注释中给出定义。</p><h2 id="指令的表示"><a href="#指令的表示" class="headerlink" title="指令的表示"></a>指令的表示</h2><p>在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。</p><p>逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not）。</p><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>赋值语句是如下形式的语句：<code>a←b</code>。<br>这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。</p><p>变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。</p><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>goto语句具有形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label（<span class="keyword">goto</span>标号）</span><br></pre></td></tr></table></figure><p>它将导致转向具有指定标号的语句。</p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>条件语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i=<span class="number">10</span></span><br><span class="line">    then xxxx</span><br><span class="line">    <span class="keyword">else</span> xxxx <span class="comment">//else 和 then 要对齐</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">if</span> i=<span class="number">10</span></span><br><span class="line">    then xxxx <span class="comment">//if 后面必定跟上then，else后面不用跟then</span></span><br><span class="line">    elseif i=<span class="number">9</span> <span class="comment">//elseif 要连在一起写</span></span><br><span class="line">        then xxxx</span><br><span class="line">        yyyy</span><br><span class="line">    <span class="keyword">else</span>  xxxx <span class="comment">//else 跟在 elseif 的 then 对齐</span></span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>while语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> time&lt;<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span>  xxxxx <span class="comment">//while后面必定要紧跟缩进的do</span></span><br><span class="line">    xxxxx</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>for语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var &lt;- init to limit by incr </span><br><span class="line"><span class="keyword">do</span> s</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里var是循环变量（Loop Variable），init（初始值（Initial Value））、limit（终止条件值（Limit / Bound））和incr（增量（Increment / Step））都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若<code>incr≥0</code>，则只要<code>var≤limit</code>，就执行s并且将incr加到var上。（假若<code>incr&lt;0</code>，则只要<code>var≥limit</code>，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。</p><h2 id="程序的结束"><a href="#程序的结束" class="headerlink" title="程序的结束"></a>程序的结束</h2><p>exit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。</p><p>return用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>算法中的注释被括在 /<em> </em>/ 之中。</p><h2 id="函数编写"><a href="#函数编写" class="headerlink" title="函数编写"></a>函数编写</h2><p>函数的伪代码格式例子为：search（A，name）， 参数类型可以不给出，但必须在注释中说明。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>问题描述</strong><br> 给定一组学生成绩，完成以下任务：</p><ol><li>计算平均分</li><li>查找最高分</li><li>判断是否存在不及格成绩</li><li>支持按学号查询成绩</li><li>若数据非法则提前终止程序</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Algorithm StudentScoreProcess(A, n, query_id)</span><br><span class="line">/*</span><br><span class="line">A：整数数组，存储学生成绩</span><br><span class="line">n：整数，学生人数</span><br><span class="line">query_id：整数，待查询的学生编号（从1开始）</span><br><span class="line">输出：平均分、最高分、不及格提示、查询结果</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">if n &lt;= 0</span><br><span class="line">then return &quot;Error: invalid student number&quot;</span><br><span class="line"></span><br><span class="line">sum &lt;- 0</span><br><span class="line">max_score &lt;- A[1]</span><br><span class="line">has_fail &lt;- false</span><br><span class="line"></span><br><span class="line">for i &lt;- 1 to n by 1</span><br><span class="line">do</span><br><span class="line">sum &lt;- sun + A[i]</span><br><span class="line"></span><br><span class="line">if A[i] &lt; 60</span><br><span class="line">then has_fail &lt;- true</span><br><span class="line">if A[i] &gt; max_score</span><br><span class="line">then max_score &lt;- A[i]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">avg &lt;- sum / n</span><br><span class="line">if has_fail = true</span><br><span class="line">then print &quot;There exists failing score.&quot;</span><br><span class="line">else</span><br><span class="line">print &quot;All student passed.&quot;</span><br><span class="line"></span><br><span class="line">print &quot;Average score = &quot;, avg</span><br><span class="line">print &quot;Maximum score = &quot;, max_score</span><br><span class="line"></span><br><span class="line">goto QUERY</span><br><span class="line"></span><br><span class="line">/*查询模块*/</span><br><span class="line">QUERY:</span><br><span class="line">if query_id &lt; 1 or query_id &gt; n</span><br><span class="line">then return &quot;Query ID out of range&quot;</span><br><span class="line">else</span><br><span class="line">print &quot;Score of student&quot;, query_id, &quot;is &quot;, A[query_id]</span><br><span class="line"></span><br><span class="line">Function SearchScore(A, n, target)</span><br><span class="line">/*</span><br><span class="line">   A：整数数组</span><br><span class="line">   n：数组长度</span><br><span class="line">   target：待查找的成绩</span><br><span class="line">   返回：找到则返回索引，否则返回 -1</span><br><span class="line">*/</span><br><span class="line">i ← 1</span><br><span class="line">while i ≤ n</span><br><span class="line">    do</span><br><span class="line">       if A[i] = target</span><br><span class="line">           then return i</span><br><span class="line">       i ← i + 1</span><br><span class="line">   end</span><br><span class="line">return -1</span><br><span class="line"></span><br><span class="line">return &quot;Process finished&quot;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考<br><a href="https://www.cnblogs.com/linuxAndMcu/p/11242905.html">https://www.cnblogs.com/linuxAndMcu/p/11242905.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/posts/7c10b52f/"/>
      <url>/posts/7c10b52f/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>KNN（K-Nearest Neighbors，K 近邻算法）是一种 <strong>基于实例（Instance-based）</strong> 的监督学习方法，其核心思想可以概括为：<br><strong>“一个样本的类别由与它最相似的 K 个样本共同决定。”</strong></p><h2 id="物以类聚"><a href="#物以类聚" class="headerlink" title="物以类聚"></a>物以类聚</h2><p>KNN 的思想来源于人类日常生活中的直觉判断，即 <strong>“物以类聚”</strong>。</p><p>例如，在一个学生成绩数据集中：</p><ul><li>如果某个新学生的成绩与多数“优秀”学生非常接近，</li><li>那么我们有理由认为该学生也属于“优秀”类别。</li></ul><p>在 KNN 中，这种“接近”通过<strong>距离度量</strong>来进行量化。</p><h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><p>隐含了一个重要假设：<br><strong>在特征空间中，距离相近的样本具有相似的属性或类别。</strong></p><p>即：</p><ul><li>特征空间中的 <strong>局部结构</strong> 比全局模型更重要；</li><li>不同类别间在空间上应当具有一定的可分性。</li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><script type="math/tex; mode=display">\mathcal{D} = \{(x_1, y_1), (x_2, y_2), \dots, (x_n, y_n)\}</script><ul><li>$x_i \in \mathbb{R}^d$ 表示第 $i$ 个样本的特征向量；</li><li>$y_i$ 表示对应的类别标签或数值输出。</li></ul><p>对于一个待分类（或回归）的新样本 $x$，KNN 的基本步骤如下：</p><ol><li>计算样本 $x$ 与训练集中所有样本之间的距离；</li><li>按距离从小到大排序，选取距离最近的 $K$ 个样本；</li><li>根据这 $K$ 个邻居的标签对 $x$ 进行预测。</li></ol><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>KNN 算法是一种<strong>懒惰学习（Lazy Learning）</strong>方法，其训练阶段几乎不进行任何计算，主要计算集中在预测阶段。</p><p>对于一个待预测样本 $x$，KNN 的基本流程如下：</p><ol><li>计算 $x$ 与训练集中所有样本之间的距离；</li><li>按距离从小到大对样本进行排序；</li><li>选取距离最近的 $K$ 个样本作为近邻；</li><li>根据任务类型（分类或回归）输出预测结果。</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><hr><p><strong>Algorithm 1</strong>: K-Nearest Neighbors (KNN)</p><hr><p><strong>Input</strong>:  </p><ul><li>Training dataset $\mathcal{D} = {(x_1, y_1), \dots, (x_n, y_n)}$  </li><li>Query sample $x$  </li><li>Number of neighbors $K$  </li><li>Distance metric $d(\cdot, \cdot)$  </li></ul><p><strong>Output</strong>:  </p><ul><li>Predicted label $\hat{y}$</li></ul><hr><p>1:  Initialize distance list $D = \emptyset$;<br>2:  <strong>for</strong> $i = 1$ <strong>to</strong> $n$ <strong>do</strong><br>3:  Compute distance $d_i = d(x, x_i)$;<br>4:  Append $(d_i, y_i)$ to $D$;<br>5:  <strong>end for</strong>  </p><p>6:  Sort $D$ in ascending order according to $d_i$;<br>7:  Select the first $K$ elements from $D$ as $\mathcal{N}_K(x)$;  </p><p>8:  <strong>if</strong> task is classification <strong>then</strong><br>9:  $\hat{y} \leftarrow$ majority vote of labels in $ \mathcal{N}_K(x) $ ;</p><p>10: <strong>else if</strong> task is regression <strong>then</strong>  </p><p>11:  $ \hat{y} \leftarrow \frac{1}{K} \sum_{(d_i, y_i) \in \mathcal{N}_K(x)} y_i $ ;</p><p>12: <strong>end if</strong>  </p><p>13: <strong>return</strong> $\hat{y}$;</p><hr><h2 id="距离度量方法"><a href="#距离度量方法" class="headerlink" title="距离度量方法"></a>距离度量方法</h2><p>在 KNN 算法中，“相似度”的判断完全依赖于<strong>距离度量函数</strong>。<br>不同的距离度量方式会直接影响邻居的选取，从而影响最终分类或回归结果。</p><p>设两个样本点为<br>$x = (x_1, x_2, \dots, x_d)$，<br>$y = (y_1, y_2, \dots, y_d)$，<br>其中 $d$ 表示特征维度。</p><h3 id="欧式距离（Euclidean-Distance）"><a href="#欧式距离（Euclidean-Distance）" class="headerlink" title="欧式距离（Euclidean Distance）"></a>欧式距离（Euclidean Distance）</h3><p>欧氏距离是最常用、最直观的一种距离度量方式，表示两点在欧几里得空间中的直线距离。</p><script type="math/tex; mode=display">d(x, y) = \sqrt{\sum_{i=1}^{d} (x_i - y_i)^2}</script><p><strong>特点：</strong></p><ul><li>适用于连续数值型特征；</li><li>对特征尺度敏感，常需进行归一化或标准化；</li><li>在低维空间中效果较好。</li></ul><h3 id="曼哈顿距离（Manhattan-Distance）"><a href="#曼哈顿距离（Manhattan-Distance）" class="headerlink" title="曼哈顿距离（Manhattan Distance）"></a>曼哈顿距离（Manhattan Distance）</h3><p>曼哈顿距离又称为 $L_1$ 距离，表示在坐标轴方向上的距离总和。</p><script type="math/tex; mode=display">d(x, y) = \sum_{i=1}^{d} |x_i - y_i|</script><p><strong>特点：</strong></p><ul><li>对异常值相对不如欧氏距离敏感；</li><li>适用于高维或稀疏特征空间；</li><li>在某些实际应用中比欧氏距离更稳定。</li></ul><h3 id="闵可夫斯基距离（Minkowski-Distance）"><a href="#闵可夫斯基距离（Minkowski-Distance）" class="headerlink" title="闵可夫斯基距离（Minkowski Distance）"></a>闵可夫斯基距离（Minkowski Distance）</h3><p>闵可夫斯基距离是欧氏距离和曼哈顿距离的统一形式，其定义如下：</p><script type="math/tex; mode=display">d(x, y) = \left( \sum_{i=1}^{d} |x_i - y_i|^p \right)^{\frac{1}{p}}, \quad p \geq 1</script><p>当：</p><ul><li>$p = 1$ 时，为曼哈顿距离；</li><li>$p = 2$ 时，为欧氏距离；</li><li>$p \to \infty$ 时，为切比雪夫距离。</li></ul><p><strong>特点：</strong></p><ul><li>提供了一种灵活的距离度量框架；</li><li>可根据具体问题选择合适的 $p$ 值。</li></ul><h3 id="余弦相似度（Cosine-Similarity）"><a href="#余弦相似度（Cosine-Similarity）" class="headerlink" title="余弦相似度（Cosine Similarity）"></a>余弦相似度（Cosine Similarity）</h3><p>余弦相似度衡量的是两个向量在方向上的相似性，而非距离大小，常用于文本、推荐系统等领域。</p><script type="math/tex; mode=display">\text{cos}(x, y) = \frac{x \cdot y}{\|x\| \|y\|}</script><p>其中，$x \cdot y$ 表示向量点积，$|x|$ 表示向量的 $L_2$ 范数。</p><p><strong>特点：</strong></p><ul><li>与向量的模长无关；</li><li>更关注特征的方向信息；</li><li>适合高维稀疏数据。</li></ul><h2 id="参数影响"><a href="#参数影响" class="headerlink" title="参数影响"></a>参数影响</h2><p>KNN 算法的性能对参数设置高度敏感，主要包括 <strong>K 值的选择</strong> 和 <strong>距离度量方式</strong>。</p><h3 id="K值"><a href="#K值" class="headerlink" title="K值"></a>K值</h3><p>$K$ 是 KNN 中最关键的超参数，其取值直接影响模型的偏差与方差。</p><ul><li><p><strong>K 较小（如 $K=1$）</strong>：</p><ul><li>模型对噪声敏感；</li><li>决策边界复杂；</li><li>容易发生过拟合（High Variance）。</li></ul></li><li><p><strong>K 较大</strong>：</p><ul><li>决策边界更平滑；</li><li>可能忽略局部结构；</li><li>容易发生欠拟合（High Bias）。</li></ul></li></ul><p>通常需要通过交叉验证等方法选择合适的 $K$ 值。</p><h3 id="距离度量方式的影响"><a href="#距离度量方式的影响" class="headerlink" title="距离度量方式的影响"></a>距离度量方式的影响</h3><p>不同的距离度量会导致不同的“近邻”集合：</p><ul><li>欧氏距离对特征尺度敏感，需进行特征归一化；</li><li>曼哈顿距离在高维空间中更具鲁棒性；</li><li>余弦相似度更关注方向相似性而非数值大小。</li></ul><p>因此，在实际应用中应根据数据分布和任务特点选择合适的距离度量方式。</p><h3 id="特征尺度的影响"><a href="#特征尺度的影响" class="headerlink" title="特征尺度的影响"></a>特征尺度的影响</h3><p>若各特征量纲差异较大，将导致某些特征主导距离计算结果。<br>常见的解决方法包括：</p><ul><li>Min-Max 归一化；</li><li>Z-score 标准化。</li></ul><p>特征预处理是保证 KNN 算法性能的重要前提。</p><h1 id="KNN优缺点"><a href="#KNN优缺点" class="headerlink" title="KNN优缺点"></a>KNN优缺点</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OTSU</title>
      <link href="/posts/311baf7/"/>
      <url>/posts/311baf7/</url>
      
        <content type="html"><![CDATA[<h1 id="OTSU"><a href="#OTSU" class="headerlink" title="OTSU"></a>OTSU</h1><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/document/4310076">A Threshold Selection Method from Gray-Level Histograms</a></p></blockquote><p>OTSU算法也称<strong>最大类间差法</strong>，有时也称之为大津算法，由大津于1979年提出，被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度分布特性,将图像分成背景(background)和目标(object)两部分。考虑到方差是灰度分布均匀性的一种度量,理想情况下，对于同一类，其类内方差应该是很小的，同时背景和目标之间的类间方差越大,说明构成图像的两部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p><p>该方法的基本思想是根据选取的阈值将图像分为目标和背景两个部分，<strong>通过最大化类间方差（最小化类内方差），自动确定最佳分割阈值</strong></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>假设一幅灰度图像，其灰度级为 $0 \sim L-1$。</p><p>当选择某一阈值 (T) 时，图像被分为两类：</p><ul><li><strong>前景（目标）</strong>：灰度 $0 \sim T$</li><li><strong>背景</strong>：灰度 $T+1 \sim L-1$</li></ul><p>OTSU 的目标是：<br><strong>找到一个阈值 (T)，使得前景与背景的区分度最大</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="灰度直方图概率分布"><a href="#灰度直方图概率分布" class="headerlink" title="灰度直方图概率分布"></a>灰度直方图概率分布</h2><p>设图像共有 $N$ 个像素，灰度级为 $i$，则：<br>$$<br>p_i &#x3D; \frac{n_i}{N}<br>$$</p><ul><li>$n_i$：灰度为 $i$ 的像素数</li><li>$p_i$：灰度 $i$ 出现的概率</li></ul><h2 id="类概率"><a href="#类概率" class="headerlink" title="类概率"></a>类概率</h2><p>对于阈值$T$:</p><ul><li><p>前景概率：<br>$$<br>\omega_0(T) &#x3D; \sum_{i&#x3D;0}^{T} p_i<br>$$</p></li><li><p>背景概率：<br>$$<br>\omega_1(T) &#x3D; \sum_{i&#x3D;T+1}^{L-1} p_i<br>$$</p></li></ul><h2 id="类均值"><a href="#类均值" class="headerlink" title="类均值"></a>类均值</h2><ul><li><p>前景均值：<br>$$<br>\mu_0(T) &#x3D; \frac{1}{\omega_0} \sum_{i&#x3D;0}^{T} i p_i<br>$$</p></li><li><p>背景均值<br>$$<br>\mu_1(T) &#x3D; \frac{1}{\omega_1} \sum_{i&#x3D;T+1}^{L-1} i p_i<br>$$</p></li><li><p>全局均值<br>$$<br>\mu &#x3D; \sum_{i&#x3D;0}^{L-1} i p_i<br>$$</p></li></ul><h2 id="类间方差"><a href="#类间方差" class="headerlink" title="类间方差"></a>类间方差</h2><p>$$<br>\sigma_b^2(T) &#x3D; \omega_0 (\mu_0 - \mu)^2 + \omega_1 (\mu_1 - \mu)^2<br>$$<br>$$<br>&#x3D; \omega_0 \omega_1 (\mu_0 - \mu_1)^2<br>$$</p><h2 id="最优阈值选择"><a href="#最优阈值选择" class="headerlink" title="最优阈值选择"></a>最优阈值选择</h2><p>$$<br>T^* &#x3D; \arg \max_T \sigma_b^2(T)<br>$$</p><p><strong>使类间方差最大的阈值即为 OTSU 阈值</strong></p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ol><li>计算图像灰度直方图</li><li>归一化为概率分布</li><li>遍历所有可能阈值 (T)</li><li>计算类概率、类均值、类间方差</li><li>选择使类间方差最大的阈值</li><li>根据该阈值进行二值化</li></ol><h1 id="底层代码"><a href="#底层代码" class="headerlink" title="底层代码"></a>底层代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">otsu_threshold</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 计算灰度直方图</span></span><br><span class="line">    hist = np.bincount(image.ravel(), minlength=<span class="number">256</span>)</span><br><span class="line">    total = image.size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    prob = hist / total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局均值</span></span><br><span class="line">    mu_total = np.<span class="built_in">sum</span>(np.arange(<span class="number">256</span>) * prob)</span><br><span class="line"></span><br><span class="line">    omega_0 = <span class="number">0.0</span></span><br><span class="line">    mu_0 = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    max_sigma = <span class="number">0.0</span></span><br><span class="line">    best_thresh = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        omega_0 += prob[t]</span><br><span class="line">        mu_0 += t * prob[t]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> omega_0 == <span class="number">0</span> <span class="keyword">or</span> omega_0 == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        omega_1 = <span class="number">1</span> - omega_0</span><br><span class="line">        mu_1 = (mu_total - mu_0) / omega_1</span><br><span class="line">        mu_0_t = mu_0 / omega_0</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 类间方差</span></span><br><span class="line">        sigma_b = omega_0 * omega_1 * (mu_0_t - mu_1) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sigma_b &gt; max_sigma:</span><br><span class="line">            max_sigma = sigma_b</span><br><span class="line">            best_thresh = t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_thresh</span><br></pre></td></tr></table></figure><hr><p>参考：<br><a href="https://www.bilibili.com/video/BV1cM8we3EVf?vd_source=59c9078be8272e804fcbbcf1da9a9f94">10.8 大津法（OTSU）（数字图像处理，冈萨雷斯版）</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVD分解</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
